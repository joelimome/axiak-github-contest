<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Armadillo Technical: diskio Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>diskio Class Reference<br>
<small>
[<a class="el" href="a00491.html">Diskio</a>]</small>
</h1><!-- doxytag: class="diskio" -->class for saving and loading matrices and fields  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00598.html">diskio_proto.hpp</a>&gt;</code>
<p>

<p>
<a href="a00753.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">is_supported_type</a></td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#ga99252a20f066762a161ca8ceb9b2c29">gen_txt_header</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving matrices in text format. Format: "ARMA_MAT_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="a00491.html#ga99252a20f066762a161ca8ceb9b2c29"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gfea81731918e03aedf946fafceda27b5">gen_bin_header</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving matrices in binary format. Format: "ARMA_MAT_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="a00491.html#gfea81731918e03aedf946fafceda27b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#gf1b98a9e26843fbaad5a12d626053023">conv_to_hex_char</a> (const <a class="el" href="a00576.html#ged742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ge1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a> (char *out, const <a class="el" href="a00576.html#ged742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#g81ac9508b1ee96fd24338a9701aeda71">gen_tmp_name</a> (const std::string &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a quasi-random string to the given filename. The <a class="el" href="a00511.html#ge875f8ae2d57ae41e19bc529533ec40e" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> function is deliberately not used, as <a class="el" href="a00511.html#ge875f8ae2d57ae41e19bc529533ec40e" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> has an internal state that changes from call to call. Such states should not be modified in scientific applications, where the results should be reproducable and not affected by saving data.  <a href="a00491.html#g81ac9508b1ee96fd24338a9701aeda71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#g21a278d6cee27f2800429aadceaff8b1">safe_rename</a> (const std::string &amp;old_name, const std::string &amp;new_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely rename a file. Before renaming, test if we can write to the final file. This should prevent: (i) overwriting files that have been write protected, (ii) overwriting directories.  <a href="a00491.html#g21a278d6cee27f2800429aadceaff8b1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g6bdf26f1c22b7e62ae83333ba613fcc1">save_raw_ascii</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as raw text (no header, human readable). Matrices can be loaded in Matlab and Octave, as long as they don't have complex elements.  <a href="a00491.html#g6bdf26f1c22b7e62ae83333ba613fcc1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g00d2191a8f08a1a10926273bb91a766a">save_arma_ascii</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="a00491.html#g00d2191a8f08a1a10926273bb91a766a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g49a77a6aae221a4ba7e5e882777e0fd9">save_arma_ascii</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="a00491.html#g49a77a6aae221a4ba7e5e882777e0fd9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gffe954d2c7ad14e7d5cc1be747cb2a63">save_arma_binary</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="a00491.html#gffe954d2c7ad14e7d5cc1be747cb2a63"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#ge9f09785dc6a18edd49fc074514fc6c7">save_arma_binary</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="a00491.html#ge9f09785dc6a18edd49fc074514fc6c7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g9fe8365235e562f75bdcf48826dc656a">save_pgm_binary</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="a00491.html#g9fe8365235e562f75bdcf48826dc656a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gd88e7d784105a99ba8666b2cc05af0a3">save_pgm_binary</a> (const <a class="el" href="a00140.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="a00491.html#gd88e7d784105a99ba8666b2cc05af0a3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g400632d14748572e5faeecb30e7915c7">load_raw_ascii</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header.  <a href="a00491.html#g400632d14748572e5faeecb30e7915c7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g81f825e8e6474ff560b71cb1e144dbd7">load_arma_ascii</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="a00491.html#g81f825e8e6474ff560b71cb1e144dbd7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g4a8295cacc94eb458cfb09703b4f9c25">load_arma_ascii</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="a00491.html#g4a8295cacc94eb458cfb09703b4f9c25"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g8e0731ede58797f7638eda2a50af240f">load_arma_binary</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in binary format, with a header that indicates the matrix type as well as its dimensions.  <a href="a00491.html#g8e0731ede58797f7638eda2a50af240f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g72d7772ca9cd9007571c986c2052fefc">load_arma_binary</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g114a20791e59f5a1ad076c0a6153c634">load_pgm_binary</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="a00491.html#g114a20791e59f5a1ad076c0a6153c634"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g672f562ded628be461b769c7110264b3">load_pgm_binary</a> (<a class="el" href="a00140.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="a00491.html#g672f562ded628be461b769c7110264b3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g7c35415b2c32ccc17cf0b3c8ef5c4c6d">load_auto_detect</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a matrix by automatically determining its type.  <a href="a00491.html#g7c35415b2c32ccc17cf0b3c8ef5c4c6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#g95ad21ffb197a2d1c88e9305a03a1ee7">pnm_skip_comments</a> (std::fstream &amp;f)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g9b5fcbef56f1c76f5493e571dbe58f74">save_field_arma_binary</a> (const <a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gf6b48a29fa9de8cd55ca8f69a49ba884">load_field_arma_binary</a> (<a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gf5214dc63f552a99f9a3212fad9ebe46">save_field_ppm_binary</a> (const <a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gb548665b4c0b3f035b4f20775500cb7d">load_field_ppm_binary</a> (<a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#gc81cbe704e50a7b256750a391ac7bae8">save_field_std_string</a> (const <a class="el" href="a00037.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#g7b3972f2cb001aa18b83d26305b6ed00">load_field_std_string</a> (<a class="el" href="a00037.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gc7ef1ae013236ff30e38af063dd99120">load_field_auto_detect</a> (<a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a <a class="el" href="a00037.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> by automatically determining its type.  <a href="a00491.html#gc7ef1ae013236ff30e38af063dd99120"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
class for saving and loading matrices and fields 
<p>Definition at line <a class="el" href="a00598.html#l00021">21</a> of file <a class="el" href="a00598.html">diskio_proto.hpp</a>.</p>
</div>
</BODY>
</HTML>
