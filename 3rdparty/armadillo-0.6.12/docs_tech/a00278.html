<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Armadillo Technical: Row&lt; eT &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Row&lt; eT &gt; Class Template Reference<br>
<small>
[<a class="el" href="a00569.html">Row</a>]</small>
</h1><!-- doxytag: class="Row" --><!-- doxytag: inherits="Mat,Base_vec&lt; eT, Row&lt; eT &gt; &gt;" -->Class for row vectors (matrices with only one row).  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00713.html">Row_proto.hpp</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Row&lt; eT &gt;:</div>
<div class="dynsection">

<p><center><img src="a00278.png" usemap="#Row< eT >_map" border="0" alt=""></center>
<map name="Row< eT >_map">
<area href="a00140.html" alt="Mat< eT >" shape="rect" coords="0,56,177,80">
<area href="a00019.html" alt="Base_vec< eT, Row< eT > >" shape="rect" coords="187,56,364,80">
<area href="a00018.html" alt="Base< eT, Mat< eT > >" shape="rect" coords="0,0,177,24">
</map>
</div>

<p>
<a href="a00992.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#ec0f589b61e71a94e416afe386602275">elem_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the type of elements stored in the matrix  <a href="#ec0f589b61e71a94e416afe386602275"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00050.html">get_pod_type</a><br class="typebreak">
&lt; <a class="el" href="a00278.html#ec0f589b61e71a94e416afe386602275">elem_type</a> &gt;::<a class="el" href="a00140.html#646906a8fa69aef41a87811de1ed500e">pod_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#28a293d20d2dce71078a8a49a29ee54f">pod_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">if eT is std::complex, pod_type is the underlying type used by std::complex. &lt; otherwise pod_type is the same as elem_type  <a href="#28a293d20d2dce71078a8a49a29ee54f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g355101834fb8be458a06347cb367018e">Row</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#gd32a324fb4086b12519836ec1656b841">Row</a> (const <a class="el" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> N)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g6ee1cb390dd21fa63d61454ab0978d3d">Row</a> (const char *text)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00278.html">Row</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g75fc05cdb44b99a64fa9a357ad9c4b3b">operator=</a> (const char *text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create the matrix from a textual description  <a href="a00569.html#g75fc05cdb44b99a64fa9a357ad9c4b3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g186b8d8bb10e11ebcd4eb5d2c5bbd3cf">Row</a> (const <a class="el" href="a00278.html">Row</a> &amp;X)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00278.html">Row</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g336a2a5dcddefd0c5e12ef195f30c0cd">operator=</a> (const <a class="el" href="a00278.html">Row</a> &amp;X)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00278.html">Row</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#8f2258c50d31d87641866a14f3cba224">operator*=</a> (const <a class="el" href="a00278.html">Row</a> &amp;X)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#gd028555ab948e74dd6f77f33b8008e49">Row</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;X)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00278.html">Row</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#ge5837299809bee175fbb77ba522dad57">operator=</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a given matrix  <a href="a00569.html#ge5837299809bee175fbb77ba522dad57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00278.html">Row</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g09ab0ab5ebcdde644a0bbfe360fbf19b">operator*=</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix multiplication  <a href="a00569.html#g09ab0ab5ebcdde644a0bbfe360fbf19b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#gf753732789394e3ac34eb313dbadd4e1">Row</a> (const eT *aux_mem, const <a class="el" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a row vector from a given auxillary array  <a href="a00569.html#gf753732789394e3ac34eb313dbadd4e1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#380e4dc1bcae846070fbd3ff7b79ea0e">Row</a> (const <a class="el" href="a00018.html">Base</a>&lt; <a class="el" href="a00140.html#646906a8fa69aef41a87811de1ed500e">pod_type</a>, T1 &gt; &amp;A, const <a class="el" href="a00018.html">Base</a>&lt; <a class="el" href="a00140.html#646906a8fa69aef41a87811de1ed500e">pod_type</a>, T2 &gt; &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g5d00241e41fff3e3a31b634ec2c40f35">Row</a> (const <a class="el" href="a00284.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00278.html">Row</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g2b644b4435ad69c1bb4621a1a8634846">operator=</a> (const <a class="el" href="a00284.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from <a class="el" href="a00284.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (e.g. construct a matrix from a delayed submatrix operation)  <a href="a00569.html#g2b644b4435ad69c1bb4621a1a8634846"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00278.html">Row</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g193087e528c05f609360e99c098fddff">operator*=</a> (const <a class="el" href="a00284.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix mutiplication (using a submatrix on the right-hand-side)  <a href="a00569.html#g193087e528c05f609360e99c098fddff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g407f2c5a2f5742eba00afbae2701432d">Row</a> (const <a class="el" href="a00034.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a row vector from given a <a class="el" href="a00034.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a>  <a href="a00569.html#g407f2c5a2f5742eba00afbae2701432d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00278.html">Row</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g458cb2c4ab5479d5aff116b5849eb42a">operator=</a> (const <a class="el" href="a00034.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a row vector from given a <a class="el" href="a00034.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a>  <a href="a00569.html#g458cb2c4ab5479d5aff116b5849eb42a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00278.html">Row</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g392180369d2bdef10471995357d32435">operator*=</a> (const <a class="el" href="a00034.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00569.html#g70774d2cfd18429443f09236b96b8a91">Row</a> (const <a class="el" href="a00147.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00278.html">Row</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00569.html#gb178cf911cfb5801f4d4e430807eb51c">operator=</a> (const <a class="el" href="a00147.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00147.html" title="Class for storing data required for delayed unary operations, such as the operand...">Op</a>, i.e. run the previously delayed unary operations  <a href="a00569.html#gb178cf911cfb5801f4d4e430807eb51c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00278.html">Row</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00569.html#g71a5ccbdbdc36094507917536030e03d">operator*=</a> (const <a class="el" href="a00147.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix multiplication, with the right-hand-side operand having delayed operations  <a href="a00569.html#g71a5ccbdbdc36094507917536030e03d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00569.html#gebd4b17b3194a62ad786aeccc774bb50">Row</a> (const <a class="el" href="a00052.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00278.html">Row</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00569.html#g7750a63902d439be11534b63abf57873">operator=</a> (const <a class="el" href="a00052.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00052.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a>, i.e. run the previously delayed binary operations  <a href="a00569.html#g7750a63902d439be11534b63abf57873"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00278.html">Row</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00569.html#g1b396abf8142488acf5943fe0f74fed3">operator*=</a> (const <a class="el" href="a00052.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix multiplications, with the right-hand-side operands having delayed operations  <a href="a00569.html#g1b396abf8142488acf5943fe0f74fed3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#gaeb5af80e64e24b8d727f6f9adc38436">set_size</a> (const <a class="el" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> N)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g6137e389486354c825d4416cd20f59bd">set_size</a> (const <a class="el" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6">n_rows</a>, const <a class="el" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00140.html#163bed70780a1d181594d126295d5a09">n_cols</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">change the matrix to have user specified dimensions (data is not preserved)  <a href="a00569.html#g6137e389486354c825d4416cd20f59bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#gdacde0e92d10b02217a6443d754ec8b3">zeros</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g46c1d3e080ee6105d5c300bc372dd14f">zeros</a> (const <a class="el" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> N)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g761af13923663f143fd3096521bae765">zeros</a> (const <a class="el" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6">n_rows</a>, const <a class="el" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00140.html#163bed70780a1d181594d126295d5a09">n_cols</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00569.html#g28f65f7a7874ba2b81d2d83cfe232185">load</a> (const std::string name, const <a class="el" href="a00491.html#gaf047b6ce458f7c55fd215920656d128">file_type</a> type=auto_detect)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">load a matrix from a file  <a href="a00569.html#g28f65f7a7874ba2b81d2d83cfe232185"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00569.html#g03f126c05284c3c0d1a285f9c67187a5">Row</a> (const <a class="el" href="a00018.html">Base</a>&lt; typename <a class="el" href="a00278.html">Row</a>&lt; eT &gt;::<a class="el" href="a00140.html#646906a8fa69aef41a87811de1ed500e">pod_type</a>, T1 &gt; &amp;A, const <a class="el" href="a00018.html">Base</a>&lt; typename <a class="el" href="a00278.html">Row</a>&lt; eT &gt;::<a class="el" href="a00140.html#646906a8fa69aef41a87811de1ed500e">pod_type</a>, T2 &gt; &amp;B)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename eT&gt;<br>
 class Row&lt; eT &gt;</h3>

Class for row vectors (matrices with only one row). 
<p>Definition at line <a class="el" href="a00713.html#l00022">22</a> of file <a class="el" href="a00713.html">Row_proto.hpp</a>.</p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="ec0f589b61e71a94e416afe386602275"></a><!-- doxytag: member="Row::elem_type" ref="ec0f589b61e71a94e416afe386602275" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef eT <a class="el" href="a00278.html">Row</a>&lt; eT &gt;::<a class="el" href="a00278.html#ec0f589b61e71a94e416afe386602275">elem_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the type of elements stored in the matrix 
<p>

<p>Reimplemented from <a class="el" href="a00140.html#3b7c1109cca98fb4bf493b8be33c4299">Mat&lt; eT &gt;</a>.</p>

<p>Definition at line <a class="el" href="a00713.html#l00026">26</a> of file <a class="el" href="a00713.html">Row_proto.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="28a293d20d2dce71078a8a49a29ee54f"></a><!-- doxytag: member="Row::pod_type" ref="28a293d20d2dce71078a8a49a29ee54f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00050.html">get_pod_type</a>&lt;<a class="el" href="a00278.html#ec0f589b61e71a94e416afe386602275">elem_type</a>&gt;::<a class="el" href="a00140.html#646906a8fa69aef41a87811de1ed500e">pod_type</a> <a class="el" href="a00278.html">Row</a>&lt; eT &gt;::<a class="el" href="a00140.html#646906a8fa69aef41a87811de1ed500e">pod_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
if eT is std::complex, pod_type is the underlying type used by std::complex. &lt; otherwise pod_type is the same as elem_type 
<p>

<p>Reimplemented from <a class="el" href="a00140.html#646906a8fa69aef41a87811de1ed500e">Mat&lt; eT &gt;</a>.</p>

<p>Definition at line <a class="el" href="a00713.html#l00027">27</a> of file <a class="el" href="a00713.html">Row_proto.hpp</a>.</p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="380e4dc1bcae846070fbd3ff7b79ea0e"></a><!-- doxytag: member="Row::Row" ref="380e4dc1bcae846070fbd3ff7b79ea0e" args="(const Base&lt; pod_type, T1 &gt; &amp;A, const Base&lt; pod_type, T2 &gt; &amp;B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00278.html">Row</a>&lt; eT &gt;::<a class="el" href="a00278.html">Row</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00018.html">Base</a>&lt; <a class="el" href="a00140.html#646906a8fa69aef41a87811de1ed500e">pod_type</a>, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00018.html">Base</a>&lt; <a class="el" href="a00140.html#646906a8fa69aef41a87811de1ed500e">pod_type</a>, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8f2258c50d31d87641866a14f3cba224"></a><!-- doxytag: member="Row::operator*=" ref="8f2258c50d31d87641866a14f3cba224" args="(const Row &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00278.html">Row</a>&amp; <a class="el" href="a00278.html">Row</a>&lt; eT &gt;::operator*=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00278.html">Row</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="a00712.html#l00116">Row&lt; eT &gt;::operator*=()</a>.</p>

</div>
</div><p>
</div>
</BODY>
</HTML>
