<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Armadillo Technical: Diskio</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Diskio</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">diskio</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">class for saving and loading matrices and fields  <a href="a00035.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#gaf047b6ce458f7c55fd215920656d128">file_type</a> { <br>
&nbsp;&nbsp;<a class="el" href="a00491.html#ggaf047b6ce458f7c55fd215920656d128b23ff78608de192c57782353f7562e41">auto_detect</a>, 
<a class="el" href="a00491.html#ggaf047b6ce458f7c55fd215920656d128628746bcaf26dfa0c59b37713c27eea3">raw_ascii</a>, 
<a class="el" href="a00491.html#ggaf047b6ce458f7c55fd215920656d128a8404637cbf0a8edb1b2697ed8be514c">arma_ascii</a>, 
<a class="el" href="a00491.html#ggaf047b6ce458f7c55fd215920656d12884c7cef68df29f3a127038737c4cbdb6">arma_binary</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="a00491.html#ggaf047b6ce458f7c55fd215920656d1280b14fb78700351dca695ede008144dda">pgm_binary</a>, 
<a class="el" href="a00491.html#ggaf047b6ce458f7c55fd215920656d128152928479a10a889bbde6f10f480ac08">ppm_binary</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">file types supported by Armadillo  <a href="a00491.html#gaf047b6ce458f7c55fd215920656d128">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#ga99252a20f066762a161ca8ceb9b2c29">diskio::gen_txt_header</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving matrices in text format. Format: "ARMA_MAT_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="#ga99252a20f066762a161ca8ceb9b2c29"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gfea81731918e03aedf946fafceda27b5">diskio::gen_bin_header</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving matrices in binary format. Format: "ARMA_MAT_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="#gfea81731918e03aedf946fafceda27b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#gf1b98a9e26843fbaad5a12d626053023">diskio::conv_to_hex_char</a> (const <a class="el" href="a00576.html#ged742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#ge1927b3ea8735a7d1e77d89405f592e3">diskio::conv_to_hex</a> (char *out, const <a class="el" href="a00576.html#ged742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#g81ac9508b1ee96fd24338a9701aeda71">diskio::gen_tmp_name</a> (const std::string &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a quasi-random string to the given filename. The <a class="el" href="a00511.html#ge875f8ae2d57ae41e19bc529533ec40e" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> function is deliberately not used, as <a class="el" href="a00511.html#ge875f8ae2d57ae41e19bc529533ec40e" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> has an internal state that changes from call to call. Such states should not be modified in scientific applications, where the results should be reproducable and not affected by saving data.  <a href="#g81ac9508b1ee96fd24338a9701aeda71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#g21a278d6cee27f2800429aadceaff8b1">diskio::safe_rename</a> (const std::string &amp;old_name, const std::string &amp;new_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely rename a file. Before renaming, test if we can write to the final file. This should prevent: (i) overwriting files that have been write protected, (ii) overwriting directories.  <a href="#g21a278d6cee27f2800429aadceaff8b1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g6bdf26f1c22b7e62ae83333ba613fcc1">diskio::save_raw_ascii</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as raw text (no header, human readable). Matrices can be loaded in Matlab and Octave, as long as they don't have complex elements.  <a href="#g6bdf26f1c22b7e62ae83333ba613fcc1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g00d2191a8f08a1a10926273bb91a766a">diskio::save_arma_ascii</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#g00d2191a8f08a1a10926273bb91a766a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g49a77a6aae221a4ba7e5e882777e0fd9">diskio::save_arma_ascii</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#g49a77a6aae221a4ba7e5e882777e0fd9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gffe954d2c7ad14e7d5cc1be747cb2a63">diskio::save_arma_binary</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="#gffe954d2c7ad14e7d5cc1be747cb2a63"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#ge9f09785dc6a18edd49fc074514fc6c7">diskio::save_arma_binary</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="#ge9f09785dc6a18edd49fc074514fc6c7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g9fe8365235e562f75bdcf48826dc656a">diskio::save_pgm_binary</a> (const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="#g9fe8365235e562f75bdcf48826dc656a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gd88e7d784105a99ba8666b2cc05af0a3">diskio::save_pgm_binary</a> (const <a class="el" href="a00140.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="#gd88e7d784105a99ba8666b2cc05af0a3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g400632d14748572e5faeecb30e7915c7">diskio::load_raw_ascii</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header.  <a href="#g400632d14748572e5faeecb30e7915c7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g81f825e8e6474ff560b71cb1e144dbd7">diskio::load_arma_ascii</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#g81f825e8e6474ff560b71cb1e144dbd7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g4a8295cacc94eb458cfb09703b4f9c25">diskio::load_arma_ascii</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#g4a8295cacc94eb458cfb09703b4f9c25"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g8e0731ede58797f7638eda2a50af240f">diskio::load_arma_binary</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in binary format, with a header that indicates the matrix type as well as its dimensions.  <a href="#g8e0731ede58797f7638eda2a50af240f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g72d7772ca9cd9007571c986c2052fefc">diskio::load_arma_binary</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#g95ad21ffb197a2d1c88e9305a03a1ee7">diskio::pnm_skip_comments</a> (std::fstream &amp;f)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g114a20791e59f5a1ad076c0a6153c634">diskio::load_pgm_binary</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="#g114a20791e59f5a1ad076c0a6153c634"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g672f562ded628be461b769c7110264b3">diskio::load_pgm_binary</a> (<a class="el" href="a00140.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="#g672f562ded628be461b769c7110264b3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g7c35415b2c32ccc17cf0b3c8ef5c4c6d">diskio::load_auto_detect</a> (<a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a matrix by automatically determining its type.  <a href="#g7c35415b2c32ccc17cf0b3c8ef5c4c6d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#g9b5fcbef56f1c76f5493e571dbe58f74">diskio::save_field_arma_binary</a> (const <a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gf6b48a29fa9de8cd55ca8f69a49ba884">diskio::load_field_arma_binary</a> (<a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gf5214dc63f552a99f9a3212fad9ebe46">diskio::save_field_ppm_binary</a> (const <a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gb548665b4c0b3f035b4f20775500cb7d">diskio::load_field_ppm_binary</a> (<a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#gc81cbe704e50a7b256750a391ac7bae8">diskio::save_field_std_string</a> (const <a class="el" href="a00037.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00491.html#g7b3972f2cb001aa18b83d26305b6ed00">diskio::load_field_std_string</a> (<a class="el" href="a00037.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00491.html#gc7ef1ae013236ff30e38af063dd99120">diskio::load_field_auto_detect</a> (<a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a <a class="el" href="a00037.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> by automatically determining its type.  <a href="#gc7ef1ae013236ff30e38af063dd99120"></a><br></td></tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="gaf047b6ce458f7c55fd215920656d128"></a><!-- doxytag: member="forward_proto.hpp::file_type" ref="gaf047b6ce458f7c55fd215920656d128" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00491.html#gaf047b6ce458f7c55fd215920656d128">file_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
file types supported by Armadillo 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggaf047b6ce458f7c55fd215920656d128b23ff78608de192c57782353f7562e41"></a><!-- doxytag: member="auto_detect" ref="ggaf047b6ce458f7c55fd215920656d128b23ff78608de192c57782353f7562e41" args="" -->auto_detect</em>&nbsp;</td><td>
Automatically detect the file type (file must be one of the following types). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggaf047b6ce458f7c55fd215920656d128628746bcaf26dfa0c59b37713c27eea3"></a><!-- doxytag: member="raw_ascii" ref="ggaf047b6ce458f7c55fd215920656d128628746bcaf26dfa0c59b37713c27eea3" args="" -->raw_ascii</em>&nbsp;</td><td>
ASCII format (text), without any other information. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggaf047b6ce458f7c55fd215920656d128a8404637cbf0a8edb1b2697ed8be514c"></a><!-- doxytag: member="arma_ascii" ref="ggaf047b6ce458f7c55fd215920656d128a8404637cbf0a8edb1b2697ed8be514c" args="" -->arma_ascii</em>&nbsp;</td><td>
Armadillo ASCII format (text), with information about matrix type and size. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggaf047b6ce458f7c55fd215920656d12884c7cef68df29f3a127038737c4cbdb6"></a><!-- doxytag: member="arma_binary" ref="ggaf047b6ce458f7c55fd215920656d12884c7cef68df29f3a127038737c4cbdb6" args="" -->arma_binary</em>&nbsp;</td><td>
Armadillo binary format. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggaf047b6ce458f7c55fd215920656d1280b14fb78700351dca695ede008144dda"></a><!-- doxytag: member="pgm_binary" ref="ggaf047b6ce458f7c55fd215920656d1280b14fb78700351dca695ede008144dda" args="" -->pgm_binary</em>&nbsp;</td><td>
Portable Grey Map (greyscale image). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggaf047b6ce458f7c55fd215920656d128152928479a10a889bbde6f10f480ac08"></a><!-- doxytag: member="ppm_binary" ref="ggaf047b6ce458f7c55fd215920656d128152928479a10a889bbde6f10f480ac08" args="" -->ppm_binary</em>&nbsp;</td><td>
Portable Pixel Map (colour image), used by the <a class="el" href="a00037.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> class only. </td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="a00633.html#l00075">75</a> of file <a class="el" href="a00633.html">forward_proto.hpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00076"></a>00076   {
<a name="l00077"></a>00077   <a class="code" href="a00491.html#ggaf047b6ce458f7c55fd215920656d128b23ff78608de192c57782353f7562e41" title="Automatically detect the file type (file must be one of the following types).">auto_detect</a>,  <span class="comment">//!&lt; Automatically detect the file type (file must be one of the following types)</span>
<a name="l00078"></a>00078 <span class="comment"></span>  <a class="code" href="a00491.html#ggaf047b6ce458f7c55fd215920656d128628746bcaf26dfa0c59b37713c27eea3" title="ASCII format (text), without any other information.">raw_ascii</a>,    <span class="comment">//!&lt; ASCII format (text), without any other information.</span>
<a name="l00079"></a>00079 <span class="comment"></span>  <a class="code" href="a00491.html#ggaf047b6ce458f7c55fd215920656d128a8404637cbf0a8edb1b2697ed8be514c" title="Armadillo ASCII format (text), with information about matrix type and size.">arma_ascii</a>,   <span class="comment">//!&lt; Armadillo ASCII format (text), with information about matrix type and size</span>
<a name="l00080"></a>00080 <span class="comment"></span>  <a class="code" href="a00491.html#ggaf047b6ce458f7c55fd215920656d12884c7cef68df29f3a127038737c4cbdb6" title="Armadillo binary format.">arma_binary</a>,  <span class="comment">//!&lt; Armadillo binary format</span>
<a name="l00081"></a>00081 <span class="comment"></span>  <a class="code" href="a00491.html#ggaf047b6ce458f7c55fd215920656d1280b14fb78700351dca695ede008144dda" title="Portable Grey Map (greyscale image).">pgm_binary</a>,   <span class="comment">//!&lt; Portable Grey Map (greyscale image)</span>
<a name="l00082"></a>00082 <span class="comment"></span>  <a class="code" href="a00491.html#ggaf047b6ce458f7c55fd215920656d128152928479a10a889bbde6f10f480ac08" title="Portable Pixel Map (colour image), used by the field class only.">ppm_binary</a>    <span class="comment">//!&lt; Portable Pixel Map (colour image), used by the field class only</span>
<a name="l00083"></a>00083 <span class="comment"></span>  };
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga99252a20f066762a161ca8ceb9b2c29"></a><!-- doxytag: member="diskio::gen_txt_header" ref="ga99252a20f066762a161ca8ceb9b2c29" args="(const Mat&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_txt_header           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate the first line of the header used for saving matrices in text format. Format: "ARMA_MAT_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00028">28</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00597.html#l00703">load_arma_ascii()</a>, and <a class="el" href="a00597.html#l00398">save_arma_ascii()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00029"></a>00029   {
<a name="l00030"></a>00030   <a class="code" href="a00015.html">arma_type_check&lt;diskio::is_supported_type&lt;eT&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l00031"></a>00031 
<a name="l00032"></a>00032   <span class="keywordflow">if</span>(<a class="code" href="a00116.html">is_u8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00033"></a>00033     {
<a name="l00034"></a>00034     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_IU001"</span>);
<a name="l00035"></a>00035     }
<a name="l00036"></a>00036   <span class="keywordflow">else</span>
<a name="l00037"></a>00037   <span class="keywordflow">if</span>(<a class="code" href="a00097.html">is_s8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00038"></a>00038     {
<a name="l00039"></a>00039     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_IS001"</span>);
<a name="l00040"></a>00040     }
<a name="l00041"></a>00041   <span class="keywordflow">else</span>
<a name="l00042"></a>00042   <span class="keywordflow">if</span>(<a class="code" href="a00112.html">is_u16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00043"></a>00043     {
<a name="l00044"></a>00044     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_IU002"</span>);
<a name="l00045"></a>00045     }
<a name="l00046"></a>00046   <span class="keywordflow">else</span>
<a name="l00047"></a>00047   <span class="keywordflow">if</span>(<a class="code" href="a00093.html">is_s16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00048"></a>00048     {
<a name="l00049"></a>00049     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_IS002"</span>);
<a name="l00050"></a>00050     }
<a name="l00051"></a>00051   <span class="keywordflow">else</span>
<a name="l00052"></a>00052   <span class="keywordflow">if</span>(<a class="code" href="a00114.html">is_u32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00053"></a>00053     {
<a name="l00054"></a>00054     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_IU004"</span>);
<a name="l00055"></a>00055     }
<a name="l00056"></a>00056   <span class="keywordflow">else</span>
<a name="l00057"></a>00057   <span class="keywordflow">if</span>(<a class="code" href="a00095.html">is_s32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00058"></a>00058     {
<a name="l00059"></a>00059     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_IS004"</span>);
<a name="l00060"></a>00060     }
<a name="l00061"></a>00061   <span class="keywordflow">else</span>
<a name="l00062"></a>00062   <span class="keywordflow">if</span>(<a class="code" href="a00076.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00063"></a>00063     {
<a name="l00064"></a>00064     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_FN004"</span>);
<a name="l00065"></a>00065     }
<a name="l00066"></a>00066   <span class="keywordflow">else</span>
<a name="l00067"></a>00067   <span class="keywordflow">if</span>(<a class="code" href="a00074.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00068"></a>00068     {
<a name="l00069"></a>00069     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_FN008"</span>);
<a name="l00070"></a>00070     }
<a name="l00071"></a>00071   <span class="keywordflow">else</span>
<a name="l00072"></a>00072   <span class="keywordflow">if</span>(<a class="code" href="a00071.html">is_complex_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00073"></a>00073     {
<a name="l00074"></a>00074     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_FC008"</span>);
<a name="l00075"></a>00075     }
<a name="l00076"></a>00076   <span class="keywordflow">else</span>
<a name="l00077"></a>00077   <span class="keywordflow">if</span>(<a class="code" href="a00069.html">is_complex_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00078"></a>00078     {
<a name="l00079"></a>00079     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_FC016"</span>);
<a name="l00080"></a>00080     }
<a name="l00081"></a>00081   <span class="keywordflow">else</span>
<a name="l00082"></a>00082     {
<a name="l00083"></a>00083     <span class="keywordflow">return</span> std::string();
<a name="l00084"></a>00084     }
<a name="l00085"></a>00085   
<a name="l00086"></a>00086   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gfea81731918e03aedf946fafceda27b5"></a><!-- doxytag: member="diskio::gen_bin_header" ref="gfea81731918e03aedf946fafceda27b5" args="(const Mat&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_bin_header           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate the first line of the header used for saving matrices in binary format. Format: "ARMA_MAT_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00098">98</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00597.html#l00779">load_arma_binary()</a>, and <a class="el" href="a00597.html#l00482">save_arma_binary()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00099"></a>00099   {
<a name="l00100"></a>00100   <a class="code" href="a00015.html">arma_type_check&lt;diskio::is_supported_type&lt;eT&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l00101"></a>00101   
<a name="l00102"></a>00102   <span class="keywordflow">if</span>(<a class="code" href="a00116.html">is_u8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00103"></a>00103     {
<a name="l00104"></a>00104     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_IU001"</span>);
<a name="l00105"></a>00105     }
<a name="l00106"></a>00106   <span class="keywordflow">else</span>
<a name="l00107"></a>00107   <span class="keywordflow">if</span>(<a class="code" href="a00097.html">is_s8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00108"></a>00108     {
<a name="l00109"></a>00109     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_IS001"</span>);
<a name="l00110"></a>00110     }
<a name="l00111"></a>00111   <span class="keywordflow">else</span>
<a name="l00112"></a>00112   <span class="keywordflow">if</span>(<a class="code" href="a00112.html">is_u16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00113"></a>00113     {
<a name="l00114"></a>00114     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_IU002"</span>);
<a name="l00115"></a>00115     }
<a name="l00116"></a>00116   <span class="keywordflow">else</span>
<a name="l00117"></a>00117   <span class="keywordflow">if</span>(<a class="code" href="a00093.html">is_s16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00118"></a>00118     {
<a name="l00119"></a>00119     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_IS002"</span>);
<a name="l00120"></a>00120     }
<a name="l00121"></a>00121   <span class="keywordflow">else</span>
<a name="l00122"></a>00122   <span class="keywordflow">if</span>(<a class="code" href="a00114.html">is_u32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00123"></a>00123     {
<a name="l00124"></a>00124     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_IU004"</span>);
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126   <span class="keywordflow">else</span>
<a name="l00127"></a>00127   <span class="keywordflow">if</span>(<a class="code" href="a00095.html">is_s32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00128"></a>00128     {
<a name="l00129"></a>00129     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_IS004"</span>);
<a name="l00130"></a>00130     }
<a name="l00131"></a>00131   <span class="keywordflow">else</span>
<a name="l00132"></a>00132   <span class="keywordflow">if</span>(<a class="code" href="a00076.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00133"></a>00133     {
<a name="l00134"></a>00134     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_FN004"</span>);
<a name="l00135"></a>00135     }
<a name="l00136"></a>00136   <span class="keywordflow">else</span>
<a name="l00137"></a>00137   <span class="keywordflow">if</span>(<a class="code" href="a00074.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00138"></a>00138     {
<a name="l00139"></a>00139     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_FN008"</span>);
<a name="l00140"></a>00140     }
<a name="l00141"></a>00141   <span class="keywordflow">else</span>
<a name="l00142"></a>00142   <span class="keywordflow">if</span>(<a class="code" href="a00071.html">is_complex_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00143"></a>00143     {
<a name="l00144"></a>00144     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_FC008"</span>);
<a name="l00145"></a>00145     }
<a name="l00146"></a>00146   <span class="keywordflow">else</span>
<a name="l00147"></a>00147   <span class="keywordflow">if</span>(<a class="code" href="a00069.html">is_complex_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00148"></a>00148     {
<a name="l00149"></a>00149     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_FC016"</span>);
<a name="l00150"></a>00150     }
<a name="l00151"></a>00151   <span class="keywordflow">else</span>
<a name="l00152"></a>00152     {
<a name="l00153"></a>00153     <span class="keywordflow">return</span> std::string();
<a name="l00154"></a>00154     }
<a name="l00155"></a>00155   
<a name="l00156"></a>00156   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gf1b98a9e26843fbaad5a12d626053023"></a><!-- doxytag: member="diskio::conv_to_hex_char" ref="gf1b98a9e26843fbaad5a12d626053023" args="(const u8 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char diskio::conv_to_hex_char           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00576.html#ged742c436da53c1080638ce6ef7d13de">u8</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00597.html#l00162">162</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00597.html#l00193">conv_to_hex()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00163"></a>00163   {
<a name="l00164"></a>00164   <span class="keywordtype">char</span> out;
<a name="l00165"></a>00165   <span class="keywordflow">switch</span>(x)
<a name="l00166"></a>00166     {
<a name="l00167"></a>00167     <span class="keywordflow">case</span>  0: out = <span class="charliteral">'0'</span>; <span class="keywordflow">break</span>;
<a name="l00168"></a>00168     <span class="keywordflow">case</span>  1: out = <span class="charliteral">'1'</span>; <span class="keywordflow">break</span>;
<a name="l00169"></a>00169     <span class="keywordflow">case</span>  2: out = <span class="charliteral">'2'</span>; <span class="keywordflow">break</span>;
<a name="l00170"></a>00170     <span class="keywordflow">case</span>  3: out = <span class="charliteral">'3'</span>; <span class="keywordflow">break</span>;
<a name="l00171"></a>00171     <span class="keywordflow">case</span>  4: out = <span class="charliteral">'4'</span>; <span class="keywordflow">break</span>;
<a name="l00172"></a>00172     <span class="keywordflow">case</span>  5: out = <span class="charliteral">'5'</span>; <span class="keywordflow">break</span>;
<a name="l00173"></a>00173     <span class="keywordflow">case</span>  6: out = <span class="charliteral">'6'</span>; <span class="keywordflow">break</span>;
<a name="l00174"></a>00174     <span class="keywordflow">case</span>  7: out = <span class="charliteral">'7'</span>; <span class="keywordflow">break</span>;
<a name="l00175"></a>00175     <span class="keywordflow">case</span>  8: out = <span class="charliteral">'8'</span>; <span class="keywordflow">break</span>;
<a name="l00176"></a>00176     <span class="keywordflow">case</span>  9: out = <span class="charliteral">'9'</span>; <span class="keywordflow">break</span>;
<a name="l00177"></a>00177     <span class="keywordflow">case</span> 10: out = <span class="charliteral">'a'</span>; <span class="keywordflow">break</span>;
<a name="l00178"></a>00178     <span class="keywordflow">case</span> 11: out = <span class="charliteral">'b'</span>; <span class="keywordflow">break</span>;
<a name="l00179"></a>00179     <span class="keywordflow">case</span> 12: out = <span class="charliteral">'c'</span>; <span class="keywordflow">break</span>;
<a name="l00180"></a>00180     <span class="keywordflow">case</span> 13: out = <span class="charliteral">'d'</span>; <span class="keywordflow">break</span>;
<a name="l00181"></a>00181     <span class="keywordflow">case</span> 14: out = <span class="charliteral">'e'</span>; <span class="keywordflow">break</span>;
<a name="l00182"></a>00182     <span class="keywordflow">case</span> 15: out = <span class="charliteral">'f'</span>; <span class="keywordflow">break</span>;
<a name="l00183"></a>00183     <span class="keywordflow">default</span>: out = <span class="charliteral">'-'</span>; <span class="keywordflow">break</span>;
<a name="l00184"></a>00184     }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186   <span class="keywordflow">return</span> out;  
<a name="l00187"></a>00187   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ge1927b3ea8735a7d1e77d89405f592e3"></a><!-- doxytag: member="diskio::conv_to_hex" ref="ge1927b3ea8735a7d1e77d89405f592e3" args="(char *out, const u8 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::conv_to_hex           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00576.html#ged742c436da53c1080638ce6ef7d13de">u8</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00597.html#l00193">193</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00597.html#l00162">conv_to_hex_char()</a>.</p>

<p>Referenced by <a class="el" href="a00597.html#l00213">gen_tmp_name()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00194"></a>00194   {
<a name="l00195"></a>00195   <span class="keyword">const</span> <a class="code" href="a00576.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a> a = x / 16;
<a name="l00196"></a>00196   <span class="keyword">const</span> <a class="code" href="a00576.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a> b = x - 16*a;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198   out[0] = <a class="code" href="a00491.html#gf1b98a9e26843fbaad5a12d626053023">conv_to_hex_char</a>(a);
<a name="l00199"></a>00199   out[1] = <a class="code" href="a00491.html#gf1b98a9e26843fbaad5a12d626053023">conv_to_hex_char</a>(b);
<a name="l00200"></a>00200   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g81ac9508b1ee96fd24338a9701aeda71"></a><!-- doxytag: member="diskio::gen_tmp_name" ref="g81ac9508b1ee96fd24338a9701aeda71" args="(const std::string &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_tmp_name           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append a quasi-random string to the given filename. The <a class="el" href="a00511.html#ge875f8ae2d57ae41e19bc529533ec40e" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> function is deliberately not used, as <a class="el" href="a00511.html#ge875f8ae2d57ae41e19bc529533ec40e" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> has an internal state that changes from call to call. Such states should not be modified in scientific applications, where the results should be reproducable and not affected by saving data. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00213">213</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00597.html#l00193">conv_to_hex()</a>, and <a class="el" href="a00625.html#l00031">sum()</a>.</p>

<p>Referenced by <a class="el" href="a00597.html#l00368">save_arma_ascii()</a>, <a class="el" href="a00597.html#l00452">save_arma_binary()</a>, <a class="el" href="a00597.html#l01036">save_field_arma_binary()</a>, <a class="el" href="a00597.html#l01146">save_field_ppm_binary()</a>, <a class="el" href="a00597.html#l01352">save_field_std_string()</a>, <a class="el" href="a00597.html#l00510">save_pgm_binary()</a>, and <a class="el" href="a00597.html#l00304">save_raw_ascii()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00214"></a>00214   {
<a name="l00215"></a>00215   <span class="keyword">const</span> std::string* ptr_x     = &amp;x;
<a name="l00216"></a>00216   <span class="keyword">const</span> <a class="code" href="a00576.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*          ptr_ptr_x = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="a00576.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*<span class="keyword">&gt;</span>(&amp;ptr_x);
<a name="l00217"></a>00217   
<a name="l00218"></a>00218   <span class="keyword">const</span> <span class="keywordtype">char</span>* extra      = <span class="stringliteral">".tmp_"</span>;
<a name="l00219"></a>00219   <span class="keyword">const</span> <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>   extra_size = 5;
<a name="l00220"></a>00220   
<a name="l00221"></a>00221   <span class="keyword">const</span> <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>   tmp_size   = 2*<span class="keyword">sizeof</span>(<a class="code" href="a00576.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*) + 2*2;
<a name="l00222"></a>00222         <span class="keywordtype">char</span>  tmp[tmp_size];
<a name="l00223"></a>00223   
<a name="l00224"></a>00224   <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> char_count = 0;
<a name="l00225"></a>00225   
<a name="l00226"></a>00226   <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;<span class="keyword">sizeof</span>(<a class="code" href="a00576.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*); ++i)
<a name="l00227"></a>00227     {
<a name="l00228"></a>00228     <a class="code" href="a00491.html#ge1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a>(&amp;tmp[char_count], ptr_ptr_x[i]);
<a name="l00229"></a>00229     char_count += 2;
<a name="l00230"></a>00230     }
<a name="l00231"></a>00231   
<a name="l00232"></a>00232   <span class="keyword">const</span> <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> x_size = x.size();
<a name="l00233"></a>00233   <a class="code" href="a00576.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a> <a class="code" href="a00517.html#g3539d90506debc42c45497615cb60add" title="Delayed sum of elements of a matrix along a specified dimension (either rows or columns)...">sum</a> = 0;
<a name="l00234"></a>00234   
<a name="l00235"></a>00235   <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x_size; ++i)
<a name="l00236"></a>00236     {
<a name="l00237"></a>00237     sum += <a class="code" href="a00576.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>(x[i]);
<a name="l00238"></a>00238     }
<a name="l00239"></a>00239   
<a name="l00240"></a>00240   <a class="code" href="a00491.html#ge1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a>(&amp;tmp[char_count], sum);
<a name="l00241"></a>00241   char_count += 2;
<a name="l00242"></a>00242   
<a name="l00243"></a>00243   <a class="code" href="a00491.html#ge1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a>(&amp;tmp[char_count], <a class="code" href="a00576.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>(x_size));
<a name="l00244"></a>00244   
<a name="l00245"></a>00245   
<a name="l00246"></a>00246   std::string out;
<a name="l00247"></a>00247   out.resize(x_size + extra_size + tmp_size);
<a name="l00248"></a>00248   
<a name="l00249"></a>00249   
<a name="l00250"></a>00250   <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x_size; ++i)
<a name="l00251"></a>00251     {
<a name="l00252"></a>00252     out[i] = x[i];
<a name="l00253"></a>00253     }
<a name="l00254"></a>00254   
<a name="l00255"></a>00255   <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;extra_size; ++i)
<a name="l00256"></a>00256     {
<a name="l00257"></a>00257     out[x_size + i] = extra[i];
<a name="l00258"></a>00258     }
<a name="l00259"></a>00259   
<a name="l00260"></a>00260   <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;tmp_size; ++i)
<a name="l00261"></a>00261     {
<a name="l00262"></a>00262     out[x_size + extra_size + i] = tmp[i];
<a name="l00263"></a>00263     }
<a name="l00264"></a>00264   
<a name="l00265"></a>00265   <span class="keywordflow">return</span> out;
<a name="l00266"></a>00266   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g21a278d6cee27f2800429aadceaff8b1"></a><!-- doxytag: member="diskio::safe_rename" ref="g21a278d6cee27f2800429aadceaff8b1" args="(const std::string &amp;old_name, const std::string &amp;new_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::safe_rename           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>new_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Safely rename a file. Before renaming, test if we can write to the final file. This should prevent: (i) overwriting files that have been write protected, (ii) overwriting directories. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00277">277</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00160">arma_warn()</a>.</p>

<p>Referenced by <a class="el" href="a00597.html#l00368">save_arma_ascii()</a>, <a class="el" href="a00597.html#l00452">save_arma_binary()</a>, <a class="el" href="a00597.html#l01036">save_field_arma_binary()</a>, <a class="el" href="a00597.html#l01146">save_field_ppm_binary()</a>, <a class="el" href="a00597.html#l01352">save_field_std_string()</a>, <a class="el" href="a00597.html#l00510">save_pgm_binary()</a>, and <a class="el" href="a00597.html#l00304">save_raw_ascii()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00278"></a>00278   {
<a name="l00279"></a>00279   std::fstream f(new_name.c_str(), std::fstream::out | std::fstream::app);
<a name="l00280"></a>00280   f.put(<span class="charliteral">' '</span>);
<a name="l00281"></a>00281   
<a name="l00282"></a>00282   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00283"></a>00283   f.close();
<a name="l00284"></a>00284   
<a name="l00285"></a>00285   <a class="code" href="a00488.html#gd87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">"trouble writing "</span>, new_name );
<a name="l00286"></a>00286   
<a name="l00287"></a>00287   <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00288"></a>00288     {
<a name="l00289"></a>00289     std::remove(new_name.c_str());
<a name="l00290"></a>00290     
<a name="l00291"></a>00291     <span class="keyword">const</span> <span class="keywordtype">int</span> mv_result = std::rename(old_name.c_str(), new_name.c_str());
<a name="l00292"></a>00292     <a class="code" href="a00488.html#gd87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( (mv_result != 0), <span class="stringliteral">"trouble writing "</span>, new_name );
<a name="l00293"></a>00293     }
<a name="l00294"></a>00294   
<a name="l00295"></a>00295   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g6bdf26f1c22b7e62ae83333ba613fcc1"></a><!-- doxytag: member="diskio::save_raw_ascii" ref="g6bdf26f1c22b7e62ae83333ba613fcc1" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_raw_ascii           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix as raw text (no header, human readable). Matrices can be loaded in Matlab and Octave, as long as they don't have complex elements. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00304">304</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00593.html#l00160">arma_warn()</a>, <a class="el" href="a00653.html#l01307">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00653.html#l00732">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00597.html#l00213">gen_tmp_name()</a>, <a class="el" href="a00654.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00654.html#l00033">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00653.html#l00702">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00597.html#l00277">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00653.html#l01596">Mat&lt; eT &gt;::save()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00305"></a>00305   {
<a name="l00306"></a>00306   arma_extra_debug_sigprint();
<a name="l00307"></a>00307   
<a name="l00308"></a>00308   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00491.html#g81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00309"></a>00309   
<a name="l00310"></a>00310   std::fstream f(tmp_name.c_str(), std::fstream::out);
<a name="l00311"></a>00311   
<a name="l00312"></a>00312   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00313"></a>00313     {
<a name="l00314"></a>00314     <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unable to write "</span>, tmp_name);
<a name="l00315"></a>00315     }
<a name="l00316"></a>00316   <span class="keywordflow">else</span>
<a name="l00317"></a>00317     {
<a name="l00318"></a>00318     <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> cell_width;
<a name="l00319"></a>00319     
<a name="l00320"></a>00320     <span class="comment">// TODO: need sane values for complex numbers</span>
<a name="l00321"></a>00321     
<a name="l00322"></a>00322     <span class="keywordflow">if</span>( (<a class="code" href="a00076.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00074.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00323"></a>00323       {
<a name="l00324"></a>00324       f.setf(ios::scientific);
<a name="l00325"></a>00325       f.precision(8);
<a name="l00326"></a>00326       cell_width = 16;
<a name="l00327"></a>00327       }
<a name="l00328"></a>00328     
<a name="l00329"></a>00329     <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00330"></a>00330       {
<a name="l00331"></a>00331       <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00140.html#163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00332"></a>00332         {
<a name="l00333"></a>00333         f.put(<span class="charliteral">' '</span>);
<a name="l00334"></a>00334         
<a name="l00335"></a>00335         <span class="keywordflow">if</span>( (<a class="code" href="a00076.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00074.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00336"></a>00336           {
<a name="l00337"></a>00337           f.width(cell_width);
<a name="l00338"></a>00338           }
<a name="l00339"></a>00339         
<a name="l00340"></a>00340         f &lt;&lt; x.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col);
<a name="l00341"></a>00341         }
<a name="l00342"></a>00342         
<a name="l00343"></a>00343       f.put(<span class="charliteral">'\n'</span>);
<a name="l00344"></a>00344       }
<a name="l00345"></a>00345     
<a name="l00346"></a>00346     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00347"></a>00347     
<a name="l00348"></a>00348     <a class="code" href="a00488.html#gd87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">"trouble writing "</span>, tmp_name );
<a name="l00349"></a>00349     
<a name="l00350"></a>00350     f.flush();
<a name="l00351"></a>00351     f.close();
<a name="l00352"></a>00352     
<a name="l00353"></a>00353     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00354"></a>00354       {
<a name="l00355"></a>00355       <a class="code" href="a00491.html#g21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00356"></a>00356       }
<a name="l00357"></a>00357     }
<a name="l00358"></a>00358   
<a name="l00359"></a>00359   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g00d2191a8f08a1a10926273bb91a766a"></a><!-- doxytag: member="diskio::save_arma_ascii" ref="g00d2191a8f08a1a10926273bb91a766a" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_ascii           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00368">368</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00160">arma_warn()</a>, <a class="el" href="a00597.html#l00213">gen_tmp_name()</a>, and <a class="el" href="a00597.html#l00277">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00653.html#l01596">Mat&lt; eT &gt;::save()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00369"></a>00369   {
<a name="l00370"></a>00370   arma_extra_debug_sigprint();
<a name="l00371"></a>00371   
<a name="l00372"></a>00372   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00491.html#g81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00373"></a>00373   
<a name="l00374"></a>00374   std::ofstream f(tmp_name.c_str());
<a name="l00375"></a>00375   
<a name="l00376"></a>00376   <a class="code" href="a00491.html#g00d2191a8f08a1a10926273bb91a766a" title="Save a matrix in text format (human readable), with a header that indicates the matrix...">diskio::save_arma_ascii</a>(x, tmp_name, f);
<a name="l00377"></a>00377   
<a name="l00378"></a>00378   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00379"></a>00379   
<a name="l00380"></a>00380   f.flush();
<a name="l00381"></a>00381   f.close();
<a name="l00382"></a>00382   
<a name="l00383"></a>00383   <a class="code" href="a00488.html#gd87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">"trouble writing "</span>, tmp_name );
<a name="l00384"></a>00384   
<a name="l00385"></a>00385   <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00386"></a>00386     {
<a name="l00387"></a>00387     <a class="code" href="a00491.html#g21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00388"></a>00388     }
<a name="l00389"></a>00389   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g49a77a6aae221a4ba7e5e882777e0fd9"></a><!-- doxytag: member="diskio::save_arma_ascii" ref="g49a77a6aae221a4ba7e5e882777e0fd9" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_ascii           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00398">398</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00653.html#l01307">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00653.html#l00732">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00597.html#l00028">gen_txt_header()</a>, <a class="el" href="a00654.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00654.html#l00033">Mat&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00653.html#l00702">Mat&lt; eT &gt;::row()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00399"></a>00399   {
<a name="l00400"></a>00400   arma_extra_debug_sigprint();
<a name="l00401"></a>00401   
<a name="l00402"></a>00402   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00403"></a>00403     {
<a name="l00404"></a>00404     arma_debug_print(<span class="stringliteral">"unable to write "</span>, name);
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406   <span class="keywordflow">else</span>
<a name="l00407"></a>00407     {
<a name="l00408"></a>00408     <span class="keyword">const</span> ios::fmtflags orig_flags = f.flags();
<a name="l00409"></a>00409     
<a name="l00410"></a>00410     f &lt;&lt; <a class="code" href="a00491.html#ga99252a20f066762a161ca8ceb9b2c29" title="Generate the first line of the header used for saving matrices in text format. Format:...">diskio::gen_txt_header</a>(x) &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00411"></a>00411     f &lt;&lt; x.<a class="code" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; x.<a class="code" href="a00140.html#163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00412"></a>00412     
<a name="l00413"></a>00413     <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> cell_width;
<a name="l00414"></a>00414     
<a name="l00415"></a>00415     <span class="comment">// TODO: need sane values for complex numbers</span>
<a name="l00416"></a>00416     
<a name="l00417"></a>00417     <span class="keywordflow">if</span>( (<a class="code" href="a00076.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00074.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00418"></a>00418       {
<a name="l00419"></a>00419       f.setf(ios::scientific);
<a name="l00420"></a>00420       f.precision(8);
<a name="l00421"></a>00421       cell_width = 16;
<a name="l00422"></a>00422       }
<a name="l00423"></a>00423       
<a name="l00424"></a>00424     <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00425"></a>00425       {
<a name="l00426"></a>00426       <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00140.html#163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00427"></a>00427         {
<a name="l00428"></a>00428         f.put(<span class="charliteral">' '</span>);
<a name="l00429"></a>00429         
<a name="l00430"></a>00430         <span class="keywordflow">if</span>( (<a class="code" href="a00076.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00074.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )        
<a name="l00431"></a>00431           {
<a name="l00432"></a>00432           f.width(cell_width);
<a name="l00433"></a>00433           }
<a name="l00434"></a>00434         
<a name="l00435"></a>00435         f &lt;&lt; x.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col);
<a name="l00436"></a>00436         }
<a name="l00437"></a>00437       
<a name="l00438"></a>00438       f.put(<span class="charliteral">'\n'</span>);
<a name="l00439"></a>00439       }
<a name="l00440"></a>00440     
<a name="l00441"></a>00441     f.flags(orig_flags);
<a name="l00442"></a>00442     }
<a name="l00443"></a>00443   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gffe954d2c7ad14e7d5cc1be747cb2a63"></a><!-- doxytag: member="diskio::save_arma_binary" ref="gffe954d2c7ad14e7d5cc1be747cb2a63" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00452">452</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00160">arma_warn()</a>, <a class="el" href="a00597.html#l00213">gen_tmp_name()</a>, and <a class="el" href="a00597.html#l00277">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00653.html#l01596">Mat&lt; eT &gt;::save()</a>, and <a class="el" href="a00597.html#l01036">save_field_arma_binary()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00453"></a>00453   {
<a name="l00454"></a>00454   arma_extra_debug_sigprint();
<a name="l00455"></a>00455   
<a name="l00456"></a>00456   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00491.html#g81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00457"></a>00457   
<a name="l00458"></a>00458   std::ofstream f(tmp_name.c_str(), std::fstream::binary);
<a name="l00459"></a>00459   
<a name="l00460"></a>00460   <a class="code" href="a00491.html#gffe954d2c7ad14e7d5cc1be747cb2a63" title="Save a matrix in binary format, with a header that stores the matrix type as well...">diskio::save_arma_binary</a>(x, tmp_name, f);
<a name="l00461"></a>00461   
<a name="l00462"></a>00462   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00463"></a>00463   
<a name="l00464"></a>00464   f.flush();
<a name="l00465"></a>00465   f.close();
<a name="l00466"></a>00466   
<a name="l00467"></a>00467   <a class="code" href="a00488.html#gd87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">"trouble writing "</span>, tmp_name );
<a name="l00468"></a>00468   
<a name="l00469"></a>00469   <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00470"></a>00470     {
<a name="l00471"></a>00471     <a class="code" href="a00491.html#g21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00472"></a>00472     }
<a name="l00473"></a>00473   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ge9f09785dc6a18edd49fc074514fc6c7"></a><!-- doxytag: member="diskio::save_arma_binary" ref="ge9f09785dc6a18edd49fc074514fc6c7" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00482">482</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00597.html#l00098">gen_bin_header()</a>, <a class="el" href="a00654.html#l00037">Mat&lt; eT &gt;::mem</a>, <a class="el" href="a00654.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00654.html#l00035">Mat&lt; eT &gt;::n_elem</a>, and <a class="el" href="a00654.html#l00033">Mat&lt; eT &gt;::n_rows</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00483"></a>00483   {
<a name="l00484"></a>00484   arma_extra_debug_sigprint();
<a name="l00485"></a>00485   
<a name="l00486"></a>00486   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00487"></a>00487     {
<a name="l00488"></a>00488     <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unable to write "</span>, name);
<a name="l00489"></a>00489     }
<a name="l00490"></a>00490   <span class="keywordflow">else</span>
<a name="l00491"></a>00491     {
<a name="l00492"></a>00492     f &lt;&lt; <a class="code" href="a00491.html#gfea81731918e03aedf946fafceda27b5" title="Generate the first line of the header used for saving matrices in binary format....">diskio::gen_bin_header</a>(x) &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00493"></a>00493     f &lt;&lt; x.<a class="code" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; x.<a class="code" href="a00140.html#163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00494"></a>00494     
<a name="l00495"></a>00495     f.write(reinterpret_cast&lt;const char*&gt;(x.<a class="code" href="a00140.html#14a6badc8098d810e5decb22272a07b0" title="pointer to memory used by the matrix (memory is read-only)">mem</a>), x.<a class="code" href="a00140.html#b12257afbbe6338a7af830d9b65f3305" title="number of elements in the matrix (read-only)">n_elem</a>*<span class="keyword">sizeof</span>(eT));
<a name="l00496"></a>00496     }
<a name="l00497"></a>00497   
<a name="l00498"></a>00498   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g9fe8365235e562f75bdcf48826dc656a"></a><!-- doxytag: member="diskio::save_pgm_binary" ref="g9fe8365235e562f75bdcf48826dc656a" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_pgm_binary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix as a PGM greyscale image. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00510">510</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00593.html#l00160">arma_warn()</a>, <a class="el" href="a00653.html#l00732">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00597.html#l00213">gen_tmp_name()</a>, <a class="el" href="a00711.html#l00032">podarray&lt; T1 &gt;::mem</a>, <a class="el" href="a00654.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00654.html#l00035">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00654.html#l00033">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00653.html#l00702">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00597.html#l00277">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00653.html#l01596">Mat&lt; eT &gt;::save()</a>, and <a class="el" href="a00597.html#l00565">save_pgm_binary()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00511"></a>00511   {
<a name="l00512"></a>00512   arma_extra_debug_sigprint();
<a name="l00513"></a>00513   
<a name="l00514"></a>00514   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00491.html#g81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00515"></a>00515   
<a name="l00516"></a>00516   std::fstream f(tmp_name.c_str(), std::fstream::out | std::fstream::binary);
<a name="l00517"></a>00517   
<a name="l00518"></a>00518   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00519"></a>00519     {
<a name="l00520"></a>00520     <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unable to write "</span>, tmp_name);
<a name="l00521"></a>00521     }
<a name="l00522"></a>00522   <span class="keywordflow">else</span>
<a name="l00523"></a>00523     {
<a name="l00524"></a>00524     f &lt;&lt; <span class="stringliteral">"P5"</span> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00525"></a>00525     f &lt;&lt; x.<a class="code" href="a00140.html#163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; x.<a class="code" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00526"></a>00526     f &lt;&lt; 255 &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00527"></a>00527     
<a name="l00528"></a>00528     <span class="keyword">const</span> <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = x.<a class="code" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> * x.<a class="code" href="a00140.html#163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>;
<a name="l00529"></a>00529     <a class="code" href="a00198.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l00530"></a>00530     
<a name="l00531"></a>00531     <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l00532"></a>00532     
<a name="l00533"></a>00533     <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00534"></a>00534       {
<a name="l00535"></a>00535       <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00140.html#163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00536"></a>00536         {
<a name="l00537"></a>00537         tmp[i] = <a class="code" href="a00576.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( x(row,col) );  <span class="comment">// TODO: add round() ?</span>
<a name="l00538"></a>00538         ++i;
<a name="l00539"></a>00539         }
<a name="l00540"></a>00540       }
<a name="l00541"></a>00541     
<a name="l00542"></a>00542     f.write(reinterpret_cast&lt;const char*&gt;(tmp.mem), n_elem);
<a name="l00543"></a>00543     
<a name="l00544"></a>00544     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00545"></a>00545     
<a name="l00546"></a>00546     <a class="code" href="a00488.html#gd87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">"trouble writing "</span>, tmp_name );
<a name="l00547"></a>00547     
<a name="l00548"></a>00548     f.flush();
<a name="l00549"></a>00549     f.close();
<a name="l00550"></a>00550     
<a name="l00551"></a>00551     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00552"></a>00552       {
<a name="l00553"></a>00553       <a class="code" href="a00491.html#g21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00554"></a>00554       }
<a name="l00555"></a>00555     }
<a name="l00556"></a>00556   
<a name="l00557"></a>00557   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gd88e7d784105a99ba8666b2cc05af0a3"></a><!-- doxytag: member="diskio::save_pgm_binary" ref="gd88e7d784105a99ba8666b2cc05af0a3" args="(const Mat&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_pgm_binary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00140.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix as a PGM greyscale image. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00565">565</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00597.html#l00510">save_pgm_binary()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00566"></a>00566   {
<a name="l00567"></a>00567   arma_extra_debug_sigprint();
<a name="l00568"></a>00568   
<a name="l00569"></a>00569   <span class="keyword">const</span> <a class="code" href="a00140.html" title="Dense matrix class.">uchar_mat</a> tmp = <a class="code" href="a00026.html">conv_to&lt;uchar_mat&gt;::from</a>(x);
<a name="l00570"></a>00570   <a class="code" href="a00491.html#g9fe8365235e562f75bdcf48826dc656a" title="Save a matrix as a PGM greyscale image.">diskio::save_pgm_binary</a>(tmp,name);
<a name="l00571"></a>00571   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g400632d14748572e5faeecb30e7915c7"></a><!-- doxytag: member="diskio::load_raw_ascii" ref="g400632d14748572e5faeecb30e7915c7" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_raw_ascii           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00581">581</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00653.html#l01307">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00653.html#l00732">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00654.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00654.html#l00033">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00653.html#l01583">Mat&lt; eT &gt;::reset()</a>, <a class="el" href="a00653.html#l00702">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00653.html#l00079">Mat&lt; eT &gt;::set_size()</a>.</p>

<p>Referenced by <a class="el" href="a00653.html#l01630">Mat&lt; eT &gt;::load()</a>, and <a class="el" href="a00597.html#l00982">load_auto_detect()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00582"></a>00582   {
<a name="l00583"></a>00583   arma_extra_debug_sigprint();
<a name="l00584"></a>00584 
<a name="l00585"></a>00585   std::fstream f;
<a name="l00586"></a>00586   f.open(name.c_str(), std::fstream::in);
<a name="l00587"></a>00587   
<a name="l00588"></a>00588   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00589"></a>00589   
<a name="l00590"></a>00590   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00591"></a>00591     {
<a name="l00592"></a>00592     load_okay = <span class="keyword">false</span>;
<a name="l00593"></a>00593     arma_extra_debug_print(<span class="stringliteral">"unable to read "</span>, name);
<a name="l00594"></a>00594     }
<a name="l00595"></a>00595   <span class="keywordflow">else</span>
<a name="l00596"></a>00596     {
<a name="l00597"></a>00597     <span class="comment">//std::fstream::pos_type start = f.tellg();</span>
<a name="l00598"></a>00598     
<a name="l00599"></a>00599     <span class="comment">//</span>
<a name="l00600"></a>00600     <span class="comment">// work out the size</span>
<a name="l00601"></a>00601     
<a name="l00602"></a>00602     
<a name="l00603"></a>00603     <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l00604"></a>00604     <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l00605"></a>00605     
<a name="l00606"></a>00606     <span class="keywordtype">bool</span> f_n_cols_found = <span class="keyword">false</span>;
<a name="l00607"></a>00607     
<a name="l00608"></a>00608     std::string line_string;
<a name="l00609"></a>00609     std::string token;
<a name="l00610"></a>00610     
<a name="l00611"></a>00611     <span class="keywordflow">while</span>( (f.good() == <span class="keyword">true</span>) &amp;&amp; (load_okay == <span class="keyword">true</span>) )
<a name="l00612"></a>00612       {
<a name="l00613"></a>00613       std::getline(f, line_string);
<a name="l00614"></a>00614       <span class="keywordflow">if</span>(line_string.size() == 0)
<a name="l00615"></a>00615         <span class="keywordflow">break</span>;
<a name="l00616"></a>00616       
<a name="l00617"></a>00617       std::stringstream line_stream(line_string);
<a name="l00618"></a>00618       
<a name="l00619"></a>00619       <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> line_n_cols = 0;
<a name="l00620"></a>00620       <span class="keywordflow">while</span> (line_stream &gt;&gt; token)
<a name="l00621"></a>00621         line_n_cols++;
<a name="l00622"></a>00622       
<a name="l00623"></a>00623       <span class="keywordflow">if</span>(f_n_cols_found == <span class="keyword">false</span>)
<a name="l00624"></a>00624         {
<a name="l00625"></a>00625         f_n_cols = line_n_cols;
<a name="l00626"></a>00626         f_n_cols_found = <span class="keyword">true</span>;
<a name="l00627"></a>00627         }
<a name="l00628"></a>00628       <span class="keywordflow">else</span>
<a name="l00629"></a>00629         {
<a name="l00630"></a>00630         <span class="keywordflow">if</span>(line_n_cols != f_n_cols)
<a name="l00631"></a>00631           {
<a name="l00632"></a>00632           <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"inconsistent number of columns in "</span>, name );
<a name="l00633"></a>00633           load_okay = <span class="keyword">false</span>;
<a name="l00634"></a>00634           }
<a name="l00635"></a>00635         }
<a name="l00636"></a>00636       
<a name="l00637"></a>00637       ++f_n_rows;
<a name="l00638"></a>00638       }
<a name="l00639"></a>00639       
<a name="l00640"></a>00640     <span class="keywordflow">if</span>(load_okay == <span class="keyword">true</span>)
<a name="l00641"></a>00641       {
<a name="l00642"></a>00642       f.clear();
<a name="l00643"></a>00643       f.seekg(0, ios::beg);
<a name="l00644"></a>00644       <span class="comment">//f.seekg(start);</span>
<a name="l00645"></a>00645       
<a name="l00646"></a>00646       x.<a class="code" href="a00537.html#gc55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols);
<a name="l00647"></a>00647     
<a name="l00648"></a>00648       eT val;
<a name="l00649"></a>00649       
<a name="l00650"></a>00650       <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00651"></a>00651         {
<a name="l00652"></a>00652         <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00140.html#163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00653"></a>00653           {
<a name="l00654"></a>00654           <span class="comment">// f &gt;&gt; token;</span>
<a name="l00655"></a>00655           <span class="comment">// x.at(row,col) = eT( strtod(token.c_str(), 0) );</span>
<a name="l00656"></a>00656           
<a name="l00657"></a>00657           f &gt;&gt; val;
<a name="l00658"></a>00658           x.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = val;
<a name="l00659"></a>00659           }
<a name="l00660"></a>00660         }
<a name="l00661"></a>00661       }
<a name="l00662"></a>00662     
<a name="l00663"></a>00663     <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00664"></a>00664       {
<a name="l00665"></a>00665       <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"trouble reading "</span>, name );
<a name="l00666"></a>00666       load_okay = <span class="keyword">false</span>; 
<a name="l00667"></a>00667       }
<a name="l00668"></a>00668     
<a name="l00669"></a>00669     f.close();
<a name="l00670"></a>00670     }
<a name="l00671"></a>00671   
<a name="l00672"></a>00672   
<a name="l00673"></a>00673   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l00674"></a>00674     {
<a name="l00675"></a>00675     x.<a class="code" href="a00537.html#gcc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l00676"></a>00676     }
<a name="l00677"></a>00677   
<a name="l00678"></a>00678   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g81f825e8e6474ff560b71cb1e144dbd7"></a><!-- doxytag: member="diskio::load_arma_ascii" ref="g81f825e8e6474ff560b71cb1e144dbd7" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_ascii           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00687">687</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00653.html#l01630">Mat&lt; eT &gt;::load()</a>, and <a class="el" href="a00597.html#l00982">load_auto_detect()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00688"></a>00688   {
<a name="l00689"></a>00689   arma_extra_debug_sigprint();
<a name="l00690"></a>00690   
<a name="l00691"></a>00691   std::ifstream f(name.c_str());
<a name="l00692"></a>00692   <a class="code" href="a00491.html#g81f825e8e6474ff560b71cb1e144dbd7" title="Load a matrix in text format (human readable), with a header that indicates the matrix...">diskio::load_arma_ascii</a>(x, name, f);
<a name="l00693"></a>00693   f.close();
<a name="l00694"></a>00694   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g4a8295cacc94eb458cfb09703b4f9c25"></a><!-- doxytag: member="diskio::load_arma_ascii" ref="g4a8295cacc94eb458cfb09703b4f9c25" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_ascii           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00703">703</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00653.html#l01307">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00653.html#l00732">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00597.html#l00028">gen_txt_header()</a>, <a class="el" href="a00654.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00654.html#l00033">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00653.html#l01583">Mat&lt; eT &gt;::reset()</a>, <a class="el" href="a00653.html#l00702">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00653.html#l00079">Mat&lt; eT &gt;::set_size()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00704"></a>00704   {
<a name="l00705"></a>00705   arma_extra_debug_sigprint();
<a name="l00706"></a>00706   
<a name="l00707"></a>00707   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00708"></a>00708   
<a name="l00709"></a>00709   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00710"></a>00710     {
<a name="l00711"></a>00711     load_okay = <span class="keyword">false</span>;
<a name="l00712"></a>00712     arma_extra_debug_print(<span class="stringliteral">"unable to read "</span>, name);
<a name="l00713"></a>00713     }
<a name="l00714"></a>00714   <span class="keywordflow">else</span>
<a name="l00715"></a>00715     {
<a name="l00716"></a>00716     std::string f_header;
<a name="l00717"></a>00717     <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l00718"></a>00718     <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l00719"></a>00719     
<a name="l00720"></a>00720     f &gt;&gt; f_header;
<a name="l00721"></a>00721     f &gt;&gt; f_n_rows;
<a name="l00722"></a>00722     f &gt;&gt; f_n_cols;
<a name="l00723"></a>00723     
<a name="l00724"></a>00724     <span class="keywordflow">if</span>(f_header == <a class="code" href="a00491.html#ga99252a20f066762a161ca8ceb9b2c29" title="Generate the first line of the header used for saving matrices in text format. Format:...">diskio::gen_txt_header</a>(x))
<a name="l00725"></a>00725       {
<a name="l00726"></a>00726       x.<a class="code" href="a00537.html#gc55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols);
<a name="l00727"></a>00727       
<a name="l00728"></a>00728       <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00729"></a>00729         {
<a name="l00730"></a>00730         <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00140.html#163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00731"></a>00731           {
<a name="l00732"></a>00732           f &gt;&gt; x.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col);
<a name="l00733"></a>00733           }
<a name="l00734"></a>00734         }
<a name="l00735"></a>00735       
<a name="l00736"></a>00736       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00737"></a>00737         {
<a name="l00738"></a>00738         <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"trouble reading "</span>, name);
<a name="l00739"></a>00739         load_okay = <span class="keyword">false</span>;
<a name="l00740"></a>00740         }
<a name="l00741"></a>00741       }
<a name="l00742"></a>00742     <span class="keywordflow">else</span>
<a name="l00743"></a>00743       {
<a name="l00744"></a>00744       <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"incorrect header in "</span>, name );
<a name="l00745"></a>00745       load_okay = <span class="keyword">false</span>;
<a name="l00746"></a>00746       }
<a name="l00747"></a>00747   
<a name="l00748"></a>00748     }
<a name="l00749"></a>00749   
<a name="l00750"></a>00750   
<a name="l00751"></a>00751   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l00752"></a>00752     {
<a name="l00753"></a>00753     x.<a class="code" href="a00537.html#gcc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l00754"></a>00754     }
<a name="l00755"></a>00755   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g8e0731ede58797f7638eda2a50af240f"></a><!-- doxytag: member="diskio::load_arma_binary" ref="g8e0731ede58797f7638eda2a50af240f" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a matrix in binary format, with a header that indicates the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00764">764</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00653.html#l01630">Mat&lt; eT &gt;::load()</a>, <a class="el" href="a00597.html#l00982">load_auto_detect()</a>, and <a class="el" href="a00597.html#l01081">load_field_arma_binary()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00765"></a>00765   {
<a name="l00766"></a>00766   arma_extra_debug_sigprint();
<a name="l00767"></a>00767   
<a name="l00768"></a>00768   std::ifstream f;
<a name="l00769"></a>00769   f.open(name.c_str(), std::fstream::binary);
<a name="l00770"></a>00770   <a class="code" href="a00491.html#g8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">diskio::load_arma_binary</a>(x, name, f);
<a name="l00771"></a>00771   f.close();
<a name="l00772"></a>00772   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g72d7772ca9cd9007571c986c2052fefc"></a><!-- doxytag: member="diskio::load_arma_binary" ref="g72d7772ca9cd9007571c986c2052fefc" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00597.html#l00779">779</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00597.html#l00098">gen_bin_header()</a>, <a class="el" href="a00653.html#l01438">Mat&lt; eT &gt;::memptr()</a>, <a class="el" href="a00654.html#l00035">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00653.html#l01583">Mat&lt; eT &gt;::reset()</a>, and <a class="el" href="a00653.html#l00079">Mat&lt; eT &gt;::set_size()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00780"></a>00780   {
<a name="l00781"></a>00781   arma_extra_debug_sigprint();
<a name="l00782"></a>00782   
<a name="l00783"></a>00783   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00784"></a>00784   
<a name="l00785"></a>00785   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00786"></a>00786     {
<a name="l00787"></a>00787     load_okay = <span class="keyword">false</span>;
<a name="l00788"></a>00788     arma_extra_debug_print(<span class="stringliteral">"unable to read "</span>, name);
<a name="l00789"></a>00789     }
<a name="l00790"></a>00790   <span class="keywordflow">else</span>
<a name="l00791"></a>00791     {
<a name="l00792"></a>00792     std::string f_header;
<a name="l00793"></a>00793     <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l00794"></a>00794     <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l00795"></a>00795     
<a name="l00796"></a>00796     f &gt;&gt; f_header;
<a name="l00797"></a>00797     f &gt;&gt; f_n_rows;
<a name="l00798"></a>00798     f &gt;&gt; f_n_cols;
<a name="l00799"></a>00799     
<a name="l00800"></a>00800     <span class="keywordflow">if</span>(f_header == <a class="code" href="a00491.html#gfea81731918e03aedf946fafceda27b5" title="Generate the first line of the header used for saving matrices in binary format....">diskio::gen_bin_header</a>(x))
<a name="l00801"></a>00801       {
<a name="l00802"></a>00802       <span class="comment">//f.seekg(1, ios::cur);  // NOTE: this may not be portable, as on a Windows machine a newline could be two characters</span>
<a name="l00803"></a>00803       f.get();
<a name="l00804"></a>00804       
<a name="l00805"></a>00805       x.<a class="code" href="a00537.html#gc55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l00806"></a>00806       f.read( reinterpret_cast&lt;char *&gt;(x.<a class="code" href="a00537.html#g78bb1eef0619bccb2a13f3dfafee19bf" title="returns a pointer to array of eTs used by the matrix">memptr</a>()), x.<a class="code" href="a00140.html#b12257afbbe6338a7af830d9b65f3305" title="number of elements in the matrix (read-only)">n_elem</a>*<span class="keyword">sizeof</span>(eT));
<a name="l00807"></a>00807       
<a name="l00808"></a>00808       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00809"></a>00809         {
<a name="l00810"></a>00810         <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"trouble reading "</span>, name);
<a name="l00811"></a>00811         load_okay = <span class="keyword">false</span>;
<a name="l00812"></a>00812         }
<a name="l00813"></a>00813       }
<a name="l00814"></a>00814     <span class="keywordflow">else</span>
<a name="l00815"></a>00815       {
<a name="l00816"></a>00816       <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"incorrect header in "</span>, name);
<a name="l00817"></a>00817       load_okay = <span class="keyword">false</span>;
<a name="l00818"></a>00818       }
<a name="l00819"></a>00819     
<a name="l00820"></a>00820     }
<a name="l00821"></a>00821   
<a name="l00822"></a>00822   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l00823"></a>00823     {
<a name="l00824"></a>00824     x.<a class="code" href="a00537.html#gcc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l00825"></a>00825     }
<a name="l00826"></a>00826   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g95ad21ffb197a2d1c88e9305a03a1ee7"></a><!-- doxytag: member="diskio::pnm_skip_comments" ref="g95ad21ffb197a2d1c88e9305a03a1ee7" args="(std::fstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::pnm_skip_comments           </td>
          <td>(</td>
          <td class="paramtype">std::fstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00597.html#l00832">832</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00597.html#l01224">load_field_ppm_binary()</a>, and <a class="el" href="a00597.html#l00853">load_pgm_binary()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00833"></a>00833   {
<a name="l00834"></a>00834   <span class="keywordflow">while</span>( isspace(f.peek()) )
<a name="l00835"></a>00835     {
<a name="l00836"></a>00836     <span class="keywordflow">while</span>( isspace(f.peek()) )
<a name="l00837"></a>00837       f.get();
<a name="l00838"></a>00838   
<a name="l00839"></a>00839     <span class="keywordflow">if</span>(f.peek() == <span class="charliteral">'#'</span>)
<a name="l00840"></a>00840       {
<a name="l00841"></a>00841       <span class="keywordflow">while</span>( (f.peek() != <span class="charliteral">'\r'</span>) &amp;&amp; (f.peek()!=<span class="charliteral">'\n'</span>) )
<a name="l00842"></a>00842         f.get();
<a name="l00843"></a>00843       }
<a name="l00844"></a>00844     }
<a name="l00845"></a>00845   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g114a20791e59f5a1ad076c0a6153c634"></a><!-- doxytag: member="diskio::load_pgm_binary" ref="g114a20791e59f5a1ad076c0a6153c634" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_pgm_binary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a PGM greyscale image as a matrix. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00853">853</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00653.html#l01307">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00653.html#l00732">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00710.html#l00194">podarray&lt; T1 &gt;::memptr()</a>, <a class="el" href="a00654.html#l00035">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00597.html#l00832">pnm_skip_comments()</a>, <a class="el" href="a00653.html#l01583">Mat&lt; eT &gt;::reset()</a>, <a class="el" href="a00653.html#l00702">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00653.html#l00079">Mat&lt; eT &gt;::set_size()</a>.</p>

<p>Referenced by <a class="el" href="a00653.html#l01630">Mat&lt; eT &gt;::load()</a>, and <a class="el" href="a00597.html#l00982">load_auto_detect()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00854"></a>00854   {
<a name="l00855"></a>00855   arma_extra_debug_sigprint();
<a name="l00856"></a>00856   
<a name="l00857"></a>00857   std::fstream f;
<a name="l00858"></a>00858   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l00859"></a>00859   
<a name="l00860"></a>00860   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00861"></a>00861   
<a name="l00862"></a>00862   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00863"></a>00863     {
<a name="l00864"></a>00864     load_okay = <span class="keyword">false</span>;
<a name="l00865"></a>00865     arma_extra_debug_print(<span class="stringliteral">"unable to read "</span>, name);
<a name="l00866"></a>00866     }
<a name="l00867"></a>00867   <span class="keywordflow">else</span>
<a name="l00868"></a>00868     {
<a name="l00869"></a>00869     std::string f_header;
<a name="l00870"></a>00870     f &gt;&gt; f_header;
<a name="l00871"></a>00871     
<a name="l00872"></a>00872     <span class="keywordflow">if</span>(f_header == <span class="stringliteral">"P5"</span>)
<a name="l00873"></a>00873       {
<a name="l00874"></a>00874       <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l00875"></a>00875       <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l00876"></a>00876       <span class="keywordtype">int</span> f_maxval = 0;
<a name="l00877"></a>00877     
<a name="l00878"></a>00878       <a class="code" href="a00491.html#g95ad21ffb197a2d1c88e9305a03a1ee7">diskio::pnm_skip_comments</a>(f);
<a name="l00879"></a>00879     
<a name="l00880"></a>00880       f &gt;&gt; f_n_cols;
<a name="l00881"></a>00881       <a class="code" href="a00491.html#g95ad21ffb197a2d1c88e9305a03a1ee7">diskio::pnm_skip_comments</a>(f);
<a name="l00882"></a>00882     
<a name="l00883"></a>00883       f &gt;&gt; f_n_rows;
<a name="l00884"></a>00884       <a class="code" href="a00491.html#g95ad21ffb197a2d1c88e9305a03a1ee7">diskio::pnm_skip_comments</a>(f);
<a name="l00885"></a>00885     
<a name="l00886"></a>00886       f &gt;&gt; f_maxval;
<a name="l00887"></a>00887       f.get();
<a name="l00888"></a>00888       
<a name="l00889"></a>00889       <span class="keywordflow">if</span>( (f_maxval &gt; 0) || (f_maxval &lt;= 65535) )
<a name="l00890"></a>00890         {
<a name="l00891"></a>00891         x.<a class="code" href="a00537.html#gc55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l00892"></a>00892         
<a name="l00893"></a>00893         <span class="keywordflow">if</span>(f_maxval &lt;= 255)
<a name="l00894"></a>00894           {
<a name="l00895"></a>00895           <span class="keyword">const</span> <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = f_n_cols*f_n_rows;
<a name="l00896"></a>00896           <a class="code" href="a00198.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l00897"></a>00897           
<a name="l00898"></a>00898           f.read( reinterpret_cast&lt;char*&gt;(tmp.memptr()), n_elem);
<a name="l00899"></a>00899           
<a name="l00900"></a>00900           <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l00901"></a>00901           
<a name="l00902"></a>00902           <span class="comment">//cout &lt;&lt; "f_n_cols = " &lt;&lt; f_n_cols &lt;&lt; endl;</span>
<a name="l00903"></a>00903           <span class="comment">//cout &lt;&lt; "f_n_rows = " &lt;&lt; f_n_rows &lt;&lt; endl;</span>
<a name="l00904"></a>00904           
<a name="l00905"></a>00905           
<a name="l00906"></a>00906           <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l00907"></a>00907             {
<a name="l00908"></a>00908             <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l00909"></a>00909               {
<a name="l00910"></a>00910               x.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i]);
<a name="l00911"></a>00911               ++i;
<a name="l00912"></a>00912               }
<a name="l00913"></a>00913             
<a name="l00914"></a>00914             }
<a name="l00915"></a>00915           }
<a name="l00916"></a>00916         <span class="keywordflow">else</span>
<a name="l00917"></a>00917           {
<a name="l00918"></a>00918           <span class="keyword">const</span> <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = f_n_cols*f_n_rows;
<a name="l00919"></a>00919           <a class="code" href="a00198.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u16&gt;</a> tmp(n_elem);
<a name="l00920"></a>00920           
<a name="l00921"></a>00921           f.read( reinterpret_cast&lt;char *&gt;(tmp.memptr()), n_elem*2);
<a name="l00922"></a>00922           
<a name="l00923"></a>00923           <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l00924"></a>00924           
<a name="l00925"></a>00925           <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l00926"></a>00926             {
<a name="l00927"></a>00927             <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l00928"></a>00928               {
<a name="l00929"></a>00929               x.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i]);
<a name="l00930"></a>00930               ++i;
<a name="l00931"></a>00931               }
<a name="l00932"></a>00932             
<a name="l00933"></a>00933             }
<a name="l00934"></a>00934           
<a name="l00935"></a>00935           }
<a name="l00936"></a>00936         
<a name="l00937"></a>00937         }
<a name="l00938"></a>00938       
<a name="l00939"></a>00939       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00940"></a>00940         {
<a name="l00941"></a>00941         <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"trouble reading "</span>, name);
<a name="l00942"></a>00942         load_okay = <span class="keyword">false</span>;
<a name="l00943"></a>00943         }
<a name="l00944"></a>00944       }
<a name="l00945"></a>00945     <span class="keywordflow">else</span>
<a name="l00946"></a>00946       {
<a name="l00947"></a>00947       <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unsupported header in "</span>, name);
<a name="l00948"></a>00948       load_okay = <span class="keyword">false</span>;
<a name="l00949"></a>00949       }
<a name="l00950"></a>00950     
<a name="l00951"></a>00951     f.close();
<a name="l00952"></a>00952     }
<a name="l00953"></a>00953   
<a name="l00954"></a>00954   
<a name="l00955"></a>00955   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l00956"></a>00956     {
<a name="l00957"></a>00957     x.<a class="code" href="a00537.html#gcc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l00958"></a>00958     }
<a name="l00959"></a>00959   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g672f562ded628be461b769c7110264b3"></a><!-- doxytag: member="diskio::load_pgm_binary" ref="g672f562ded628be461b769c7110264b3" args="(Mat&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_pgm_binary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00140.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a PGM greyscale image as a matrix. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00967">967</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00653.html#l01630">Mat&lt; eT &gt;::load()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00968"></a>00968   {
<a name="l00969"></a>00969   arma_extra_debug_sigprint();
<a name="l00970"></a>00970   
<a name="l00971"></a>00971   <a class="code" href="a00140.html" title="Dense matrix class.">uchar_mat</a> tmp;
<a name="l00972"></a>00972   tmp.<a class="code" href="a00537.html#gdc2d8e5aa706f9e181f7d94bc5698eec" title="load a matrix from a file">load</a>(name);
<a name="l00973"></a>00973   x = <a class="code" href="a00026.html">conv_to&lt; Mat&lt; std::complex&lt;T&gt;</a> &gt; &gt;::from(tmp);
<a name="l00974"></a>00974   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g7c35415b2c32ccc17cf0b3c8ef5c4c6d"></a><!-- doxytag: member="diskio::load_auto_detect" ref="g7c35415b2c32ccc17cf0b3c8ef5c4c6d" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_auto_detect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00140.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Try to load a matrix by automatically determining its type. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l00982">982</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00597.html#l00687">load_arma_ascii()</a>, <a class="el" href="a00597.html#l00764">load_arma_binary()</a>, <a class="el" href="a00597.html#l00853">load_pgm_binary()</a>, <a class="el" href="a00597.html#l00581">load_raw_ascii()</a>, and <a class="el" href="a00653.html#l01583">Mat&lt; eT &gt;::reset()</a>.</p>

<p>Referenced by <a class="el" href="a00653.html#l01630">Mat&lt; eT &gt;::load()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00983"></a>00983   {
<a name="l00984"></a>00984   arma_extra_debug_sigprint();
<a name="l00985"></a>00985   
<a name="l00986"></a>00986   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_MAT_TXT = <span class="stringliteral">"ARMA_MAT_TXT"</span>;
<a name="l00987"></a>00987   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_MAT_BIN = <span class="stringliteral">"ARMA_MAT_BIN"</span>;
<a name="l00988"></a>00988   <span class="keyword">static</span> <span class="keyword">const</span> std::string           P5 = <span class="stringliteral">"P5"</span>;
<a name="l00989"></a>00989   
<a name="l00990"></a>00990   std::fstream f;
<a name="l00991"></a>00991   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l00992"></a>00992   
<a name="l00993"></a>00993   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00994"></a>00994     {
<a name="l00995"></a>00995     x.<a class="code" href="a00537.html#gcc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l00996"></a>00996     arma_extra_debug_print(<span class="stringliteral">"unable to read "</span>, name);
<a name="l00997"></a>00997     }
<a name="l00998"></a>00998   <span class="keywordflow">else</span>
<a name="l00999"></a>00999     {
<a name="l01000"></a>01000     <a class="code" href="a00198.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;char&gt;</a> raw_header(ARMA_MAT_TXT.length() + 1);
<a name="l01001"></a>01001     
<a name="l01002"></a>01002     f.read(raw_header.memptr(), ARMA_MAT_TXT.length());
<a name="l01003"></a>01003     raw_header[ARMA_MAT_TXT.length()] = <span class="charliteral">'\0'</span>;
<a name="l01004"></a>01004     
<a name="l01005"></a>01005     <span class="keyword">const</span> std::string header = raw_header.mem;
<a name="l01006"></a>01006     
<a name="l01007"></a>01007     <span class="keywordflow">if</span>(ARMA_MAT_TXT == header.substr(0,ARMA_MAT_TXT.length()))
<a name="l01008"></a>01008       {
<a name="l01009"></a>01009       <a class="code" href="a00491.html#g81f825e8e6474ff560b71cb1e144dbd7" title="Load a matrix in text format (human readable), with a header that indicates the matrix...">load_arma_ascii</a>(x, name);
<a name="l01010"></a>01010       }
<a name="l01011"></a>01011     <span class="keywordflow">else</span>
<a name="l01012"></a>01012     <span class="keywordflow">if</span>(ARMA_MAT_BIN == header.substr(0,ARMA_MAT_BIN.length()))
<a name="l01013"></a>01013       {
<a name="l01014"></a>01014       <a class="code" href="a00491.html#g8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">load_arma_binary</a>(x, name);
<a name="l01015"></a>01015       }
<a name="l01016"></a>01016     <span class="keywordflow">else</span>
<a name="l01017"></a>01017     <span class="keywordflow">if</span>(P5 == header.substr(0,P5.length()))
<a name="l01018"></a>01018       {
<a name="l01019"></a>01019       <a class="code" href="a00491.html#g114a20791e59f5a1ad076c0a6153c634" title="Load a PGM greyscale image as a matrix.">load_pgm_binary</a>(x, name);
<a name="l01020"></a>01020       }
<a name="l01021"></a>01021     <span class="keywordflow">else</span>
<a name="l01022"></a>01022       {
<a name="l01023"></a>01023       <a class="code" href="a00491.html#g400632d14748572e5faeecb30e7915c7" title="Load a matrix as raw text (no header, human readable). Can read matrices saved as...">load_raw_ascii</a>(x, name);
<a name="l01024"></a>01024       }
<a name="l01025"></a>01025     
<a name="l01026"></a>01026     f.close();
<a name="l01027"></a>01027     }
<a name="l01028"></a>01028   
<a name="l01029"></a>01029   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g9b5fcbef56f1c76f5493e571dbe58f74"></a><!-- doxytag: member="diskio::save_field_arma_binary" ref="g9b5fcbef56f1c76f5493e571dbe58f74" args="(const field&lt; T1 &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_field_arma_binary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00597.html#l01036">1036</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00593.html#l00160">arma_warn()</a>, <a class="el" href="a00597.html#l00213">gen_tmp_name()</a>, <a class="el" href="a00600.html#l00032">field&lt; oT &gt;::n_cols</a>, <a class="el" href="a00600.html#l00033">field&lt; oT &gt;::n_elem</a>, <a class="el" href="a00600.html#l00031">field&lt; oT &gt;::n_rows</a>, <a class="el" href="a00597.html#l00277">safe_rename()</a>, and <a class="el" href="a00597.html#l00452">save_arma_binary()</a>.</p>

<p>Referenced by <a class="el" href="a00599.html#l00753">field_aux::save()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01037"></a>01037   {
<a name="l01038"></a>01038   arma_extra_debug_sigprint();
<a name="l01039"></a>01039   
<a name="l01040"></a>01040   <a class="code" href="a00015.html">arma_type_check&lt;is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l01041"></a>01041   
<a name="l01042"></a>01042   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00491.html#g81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01043"></a>01043   std::ofstream f( tmp_name.c_str(), std::fstream::binary );
<a name="l01044"></a>01044   
<a name="l01045"></a>01045   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01046"></a>01046     {
<a name="l01047"></a>01047     <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"couldn't write "</span>, tmp_name);
<a name="l01048"></a>01048     }
<a name="l01049"></a>01049   <span class="keywordflow">else</span>
<a name="l01050"></a>01050     {
<a name="l01051"></a>01051     f &lt;&lt; <span class="stringliteral">"ARMA_FLD_BIN"</span> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l01052"></a>01052     f &lt;&lt; x.<a class="code" href="a00037.html#98d956dc3c4571ff9d29ee3d709d0202" title="number of rows in the field (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l01053"></a>01053     f &lt;&lt; x.<a class="code" href="a00037.html#d33a934565f6e02edb4e7f6d1331d34a" title="number of columns in the field (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l01054"></a>01054     
<a name="l01055"></a>01055     <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x.<a class="code" href="a00037.html#546aa9caedb2f0a0657e4dd765503db7" title="number of elements in the field (read-only)">n_elem</a>; ++i)
<a name="l01056"></a>01056       {
<a name="l01057"></a>01057       <a class="code" href="a00491.html#gffe954d2c7ad14e7d5cc1be747cb2a63" title="Save a matrix in binary format, with a header that stores the matrix type as well...">diskio::save_arma_binary</a>(x[i], tmp_name, f);
<a name="l01058"></a>01058       }
<a name="l01059"></a>01059     
<a name="l01060"></a>01060     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01061"></a>01061     
<a name="l01062"></a>01062     <a class="code" href="a00488.html#gd87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">"trouble writing "</span>, tmp_name );
<a name="l01063"></a>01063     
<a name="l01064"></a>01064     f.flush();
<a name="l01065"></a>01065     f.close();
<a name="l01066"></a>01066     
<a name="l01067"></a>01067     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01068"></a>01068       {
<a name="l01069"></a>01069       <a class="code" href="a00491.html#g21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01070"></a>01070       }
<a name="l01071"></a>01071     
<a name="l01072"></a>01072     }
<a name="l01073"></a>01073   
<a name="l01074"></a>01074   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gf6b48a29fa9de8cd55ca8f69a49ba884"></a><!-- doxytag: member="diskio::load_field_arma_binary" ref="gf6b48a29fa9de8cd55ca8f69a49ba884" args="(field&lt; T1 &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_field_arma_binary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00597.html#l01081">1081</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00597.html#l00764">load_arma_binary()</a>, <a class="el" href="a00600.html#l00033">field&lt; oT &gt;::n_elem</a>, <a class="el" href="a00599.html#l00478">field&lt; oT &gt;::reset()</a>, and <a class="el" href="a00599.html#l00156">field&lt; oT &gt;::set_size()</a>.</p>

<p>Referenced by <a class="el" href="a00599.html#l00777">field_aux::load()</a>, and <a class="el" href="a00597.html#l01495">load_field_auto_detect()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01082"></a>01082   {
<a name="l01083"></a>01083   arma_extra_debug_sigprint();
<a name="l01084"></a>01084   
<a name="l01085"></a>01085   <a class="code" href="a00015.html">arma_type_check&lt;is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l01086"></a>01086   
<a name="l01087"></a>01087   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01088"></a>01088   
<a name="l01089"></a>01089   std::ifstream f( name.c_str() );
<a name="l01090"></a>01090   
<a name="l01091"></a>01091   <span class="keywordflow">if</span>(f.fail())
<a name="l01092"></a>01092     {
<a name="l01093"></a>01093     load_okay = <span class="keyword">false</span>;
<a name="l01094"></a>01094     arma_extra_debug_print(<span class="stringliteral">"unable to read "</span>, name);
<a name="l01095"></a>01095     }
<a name="l01096"></a>01096   <span class="keywordflow">else</span>
<a name="l01097"></a>01097     {
<a name="l01098"></a>01098     std::string f_type;
<a name="l01099"></a>01099     f &gt;&gt; f_type;
<a name="l01100"></a>01100     
<a name="l01101"></a>01101     <span class="keywordflow">if</span>(f_type != <span class="stringliteral">"ARMA_FLD_BIN"</span>)
<a name="l01102"></a>01102       {
<a name="l01103"></a>01103       <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unsupported field type in "</span>, name);
<a name="l01104"></a>01104       load_okay = <span class="keyword">false</span>;
<a name="l01105"></a>01105       }
<a name="l01106"></a>01106     <span class="keywordflow">else</span>
<a name="l01107"></a>01107       {
<a name="l01108"></a>01108       <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l01109"></a>01109       <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l01110"></a>01110     
<a name="l01111"></a>01111       f &gt;&gt; f_n_rows;
<a name="l01112"></a>01112       f &gt;&gt; f_n_cols;
<a name="l01113"></a>01113       
<a name="l01114"></a>01114       x.<a class="code" href="a00492.html#gfd7a090f4134eab2ab1c805fb867e85c" title="change the field to have the specified number of elements, assuming a column-major...">set_size</a>(f_n_rows, f_n_cols);
<a name="l01115"></a>01115       
<a name="l01116"></a>01116       f.get();      
<a name="l01117"></a>01117       
<a name="l01118"></a>01118       <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x.<a class="code" href="a00037.html#546aa9caedb2f0a0657e4dd765503db7" title="number of elements in the field (read-only)">n_elem</a>; ++i)
<a name="l01119"></a>01119         {
<a name="l01120"></a>01120         <a class="code" href="a00491.html#g8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">diskio::load_arma_binary</a>(x[i], name, f);
<a name="l01121"></a>01121         
<a name="l01122"></a>01122         <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l01123"></a>01123           {
<a name="l01124"></a>01124           <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"trouble reading "</span>, name);
<a name="l01125"></a>01125           load_okay = <span class="keyword">false</span>;
<a name="l01126"></a>01126           <span class="keywordflow">break</span>;
<a name="l01127"></a>01127           }
<a name="l01128"></a>01128         }
<a name="l01129"></a>01129       }
<a name="l01130"></a>01130     }
<a name="l01131"></a>01131   
<a name="l01132"></a>01132   f.close();
<a name="l01133"></a>01133   
<a name="l01134"></a>01134   
<a name="l01135"></a>01135   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01136"></a>01136     {
<a name="l01137"></a>01137     x.<a class="code" href="a00492.html#gc9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l01138"></a>01138     }
<a name="l01139"></a>01139   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gf5214dc63f552a99f9a3212fad9ebe46"></a><!-- doxytag: member="diskio::save_field_ppm_binary" ref="gf5214dc63f552a99f9a3212fad9ebe46" args="(const field&lt; T1 &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_field_ppm_binary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00597.html#l01146">1146</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00593.html#l00160">arma_warn()</a>, <a class="el" href="a00653.html#l01307">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00653.html#l00732">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00597.html#l00213">gen_tmp_name()</a>, <a class="el" href="a00711.html#l00032">podarray&lt; T1 &gt;::mem</a>, <a class="el" href="a00654.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00654.html#l00035">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00600.html#l00033">field&lt; oT &gt;::n_elem</a>, <a class="el" href="a00654.html#l00033">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00653.html#l00702">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00597.html#l00277">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00599.html#l00753">field_aux::save()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01147"></a>01147   {
<a name="l01148"></a>01148   arma_extra_debug_sigprint();
<a name="l01149"></a>01149   
<a name="l01150"></a>01150   <a class="code" href="a00015.html">arma_type_check&lt;is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l01151"></a>01151   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l01152"></a>01152   
<a name="l01153"></a>01153   arma_debug_check( (x.<a class="code" href="a00037.html#546aa9caedb2f0a0657e4dd765503db7" title="number of elements in the field (read-only)">n_elem</a> != 3), <span class="stringliteral">"diskio::save_field_ppm_binary(): given field must have exactly 3 matrices of equal size"</span> );
<a name="l01154"></a>01154   
<a name="l01155"></a>01155   <span class="keywordtype">bool</span> same_size = <span class="keyword">true</span>;
<a name="l01156"></a>01156   <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=1; i&lt;3; ++i)
<a name="l01157"></a>01157     {
<a name="l01158"></a>01158     <span class="keywordflow">if</span>( (x(0).n_rows != x(i).n_rows) || (x(0).n_cols != x(i).n_cols) )
<a name="l01159"></a>01159       {
<a name="l01160"></a>01160       same_size = <span class="keyword">false</span>;
<a name="l01161"></a>01161       <span class="keywordflow">break</span>;
<a name="l01162"></a>01162       }
<a name="l01163"></a>01163     }
<a name="l01164"></a>01164   
<a name="l01165"></a>01165   arma_debug_check( (same_size != <span class="keyword">true</span>), <span class="stringliteral">"diskio::save_field_ppm_binary(): given field must have exactly 3 matrices of equal size"</span> );
<a name="l01166"></a>01166   
<a name="l01167"></a>01167   <span class="keyword">const</span> <a class="code" href="a00140.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; R = x(0);
<a name="l01168"></a>01168   <span class="keyword">const</span> <a class="code" href="a00140.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; G = x(1);
<a name="l01169"></a>01169   <span class="keyword">const</span> <a class="code" href="a00140.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; B = x(2);
<a name="l01170"></a>01170   
<a name="l01171"></a>01171   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00491.html#g81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01172"></a>01172   std::ofstream f( tmp_name.c_str(), std::fstream::binary );
<a name="l01173"></a>01173   
<a name="l01174"></a>01174   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01175"></a>01175     {
<a name="l01176"></a>01176     <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"couldn't write "</span>, tmp_name);
<a name="l01177"></a>01177     }
<a name="l01178"></a>01178   <span class="keywordflow">else</span>
<a name="l01179"></a>01179     {
<a name="l01180"></a>01180     f &lt;&lt; <span class="stringliteral">"P6"</span> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l01181"></a>01181     f &lt;&lt; R.<a class="code" href="a00140.html#163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l01182"></a>01182     f &lt;&lt; R.<a class="code" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l01183"></a>01183     f &lt;&lt; 255 &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l01184"></a>01184 
<a name="l01185"></a>01185     <span class="keyword">const</span> <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3 * R.<a class="code" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> * R.<a class="code" href="a00140.html#163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>;
<a name="l01186"></a>01186     <a class="code" href="a00198.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l01187"></a>01187 
<a name="l01188"></a>01188     <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l01189"></a>01189     <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; R.<a class="code" href="a00140.html#aa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l01190"></a>01190       {
<a name="l01191"></a>01191       <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; R.<a class="code" href="a00140.html#163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l01192"></a>01192         {
<a name="l01193"></a>01193         tmp[i+0] = <a class="code" href="a00576.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( R.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) );
<a name="l01194"></a>01194         tmp[i+1] = <a class="code" href="a00576.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( G.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) );
<a name="l01195"></a>01195         tmp[i+2] = <a class="code" href="a00576.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( B.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) );
<a name="l01196"></a>01196         
<a name="l01197"></a>01197         i+=3;
<a name="l01198"></a>01198         }
<a name="l01199"></a>01199       }
<a name="l01200"></a>01200     
<a name="l01201"></a>01201     f.write(reinterpret_cast&lt;const char*&gt;(tmp.mem), n_elem);
<a name="l01202"></a>01202     
<a name="l01203"></a>01203     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01204"></a>01204     
<a name="l01205"></a>01205     <a class="code" href="a00488.html#gd87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">"trouble writing "</span>, tmp_name );
<a name="l01206"></a>01206     
<a name="l01207"></a>01207     f.flush();
<a name="l01208"></a>01208     f.close();
<a name="l01209"></a>01209     
<a name="l01210"></a>01210     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01211"></a>01211       {
<a name="l01212"></a>01212       <a class="code" href="a00491.html#g21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01213"></a>01213       }
<a name="l01214"></a>01214     
<a name="l01215"></a>01215     }
<a name="l01216"></a>01216   
<a name="l01217"></a>01217   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gb548665b4c0b3f035b4f20775500cb7d"></a><!-- doxytag: member="diskio::load_field_ppm_binary" ref="gb548665b4c0b3f035b4f20775500cb7d" args="(field&lt; T1 &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_field_ppm_binary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00597.html#l01224">1224</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00653.html#l01307">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00653.html#l00732">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00710.html#l00194">podarray&lt; T1 &gt;::memptr()</a>, <a class="el" href="a00654.html#l00035">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00597.html#l00832">pnm_skip_comments()</a>, <a class="el" href="a00599.html#l00478">field&lt; oT &gt;::reset()</a>, <a class="el" href="a00653.html#l00702">Mat&lt; eT &gt;::row()</a>, <a class="el" href="a00653.html#l00079">Mat&lt; eT &gt;::set_size()</a>, and <a class="el" href="a00599.html#l00156">field&lt; oT &gt;::set_size()</a>.</p>

<p>Referenced by <a class="el" href="a00599.html#l00777">field_aux::load()</a>, and <a class="el" href="a00597.html#l01495">load_field_auto_detect()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01225"></a>01225   {
<a name="l01226"></a>01226   arma_extra_debug_sigprint();
<a name="l01227"></a>01227   
<a name="l01228"></a>01228   <a class="code" href="a00015.html">arma_type_check&lt;is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l01229"></a>01229   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l01230"></a>01230   
<a name="l01231"></a>01231   std::fstream f;
<a name="l01232"></a>01232   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l01233"></a>01233   
<a name="l01234"></a>01234   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01235"></a>01235   
<a name="l01236"></a>01236   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01237"></a>01237     {
<a name="l01238"></a>01238     load_okay = <span class="keyword">false</span>;
<a name="l01239"></a>01239     arma_extra_debug_print(<span class="stringliteral">"unable to read "</span>, name);
<a name="l01240"></a>01240     }
<a name="l01241"></a>01241   <span class="keywordflow">else</span>
<a name="l01242"></a>01242     {
<a name="l01243"></a>01243     std::string f_header;
<a name="l01244"></a>01244     f &gt;&gt; f_header;
<a name="l01245"></a>01245     
<a name="l01246"></a>01246     <span class="keywordflow">if</span>(f_header == <span class="stringliteral">"P6"</span>)
<a name="l01247"></a>01247       {
<a name="l01248"></a>01248       <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l01249"></a>01249       <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l01250"></a>01250       <span class="keywordtype">int</span> f_maxval = 0;
<a name="l01251"></a>01251     
<a name="l01252"></a>01252       <a class="code" href="a00491.html#g95ad21ffb197a2d1c88e9305a03a1ee7">diskio::pnm_skip_comments</a>(f);
<a name="l01253"></a>01253     
<a name="l01254"></a>01254       f &gt;&gt; f_n_cols;
<a name="l01255"></a>01255       <a class="code" href="a00491.html#g95ad21ffb197a2d1c88e9305a03a1ee7">diskio::pnm_skip_comments</a>(f);
<a name="l01256"></a>01256     
<a name="l01257"></a>01257       f &gt;&gt; f_n_rows;
<a name="l01258"></a>01258       <a class="code" href="a00491.html#g95ad21ffb197a2d1c88e9305a03a1ee7">diskio::pnm_skip_comments</a>(f);
<a name="l01259"></a>01259     
<a name="l01260"></a>01260       f &gt;&gt; f_maxval;
<a name="l01261"></a>01261       f.get();
<a name="l01262"></a>01262       
<a name="l01263"></a>01263       <span class="keywordflow">if</span>( (f_maxval &gt; 0) || (f_maxval &lt;= 65535) )
<a name="l01264"></a>01264         {
<a name="l01265"></a>01265         x.<a class="code" href="a00492.html#gfd7a090f4134eab2ab1c805fb867e85c" title="change the field to have the specified number of elements, assuming a column-major...">set_size</a>(3);
<a name="l01266"></a>01266         <a class="code" href="a00140.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; R = x(0);
<a name="l01267"></a>01267         <a class="code" href="a00140.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; G = x(1);
<a name="l01268"></a>01268         <a class="code" href="a00140.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; B = x(2);
<a name="l01269"></a>01269         
<a name="l01270"></a>01270         R.<a class="code" href="a00537.html#gc55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l01271"></a>01271         G.<a class="code" href="a00537.html#gc55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l01272"></a>01272         B.<a class="code" href="a00537.html#gc55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l01273"></a>01273         
<a name="l01274"></a>01274         <span class="keywordflow">if</span>(f_maxval &lt;= 255)
<a name="l01275"></a>01275           {
<a name="l01276"></a>01276           <span class="keyword">const</span> <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3*f_n_cols*f_n_rows;
<a name="l01277"></a>01277           <a class="code" href="a00198.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l01278"></a>01278           
<a name="l01279"></a>01279           f.read( reinterpret_cast&lt;char*&gt;(tmp.memptr()), n_elem);
<a name="l01280"></a>01280           
<a name="l01281"></a>01281           <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l01282"></a>01282           
<a name="l01283"></a>01283           <span class="comment">//cout &lt;&lt; "f_n_cols = " &lt;&lt; f_n_cols &lt;&lt; endl;</span>
<a name="l01284"></a>01284           <span class="comment">//cout &lt;&lt; "f_n_rows = " &lt;&lt; f_n_rows &lt;&lt; endl;</span>
<a name="l01285"></a>01285           
<a name="l01286"></a>01286           
<a name="l01287"></a>01287           <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l01288"></a>01288             {
<a name="l01289"></a>01289             <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l01290"></a>01290               {
<a name="l01291"></a>01291               R.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+0]);
<a name="l01292"></a>01292               G.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+1]);
<a name="l01293"></a>01293               B.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+2]);
<a name="l01294"></a>01294               i+=3;
<a name="l01295"></a>01295               }
<a name="l01296"></a>01296             
<a name="l01297"></a>01297             }
<a name="l01298"></a>01298           }
<a name="l01299"></a>01299         <span class="keywordflow">else</span>
<a name="l01300"></a>01300           {
<a name="l01301"></a>01301           <span class="keyword">const</span> <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3*f_n_cols*f_n_rows;
<a name="l01302"></a>01302           <a class="code" href="a00198.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u16&gt;</a> tmp(n_elem);
<a name="l01303"></a>01303           
<a name="l01304"></a>01304           f.read( reinterpret_cast&lt;char *&gt;(tmp.memptr()), 2*n_elem);
<a name="l01305"></a>01305           
<a name="l01306"></a>01306           <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l01307"></a>01307           
<a name="l01308"></a>01308           <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l01309"></a>01309             {
<a name="l01310"></a>01310             <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l01311"></a>01311               {
<a name="l01312"></a>01312               R.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+0]);
<a name="l01313"></a>01313               G.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+1]);
<a name="l01314"></a>01314               B.<a class="code" href="a00537.html#g6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+2]);
<a name="l01315"></a>01315               i+=3;
<a name="l01316"></a>01316               }
<a name="l01317"></a>01317             
<a name="l01318"></a>01318             }
<a name="l01319"></a>01319           
<a name="l01320"></a>01320           }
<a name="l01321"></a>01321         
<a name="l01322"></a>01322         }
<a name="l01323"></a>01323       
<a name="l01324"></a>01324       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l01325"></a>01325         {
<a name="l01326"></a>01326         <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"trouble reading "</span>, name);
<a name="l01327"></a>01327         load_okay = <span class="keyword">false</span>;
<a name="l01328"></a>01328         }
<a name="l01329"></a>01329       
<a name="l01330"></a>01330       }
<a name="l01331"></a>01331     <span class="keywordflow">else</span>
<a name="l01332"></a>01332       {
<a name="l01333"></a>01333       <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unsupported header in "</span>, name);
<a name="l01334"></a>01334       load_okay = <span class="keyword">false</span>;
<a name="l01335"></a>01335       }
<a name="l01336"></a>01336     
<a name="l01337"></a>01337     f.close();
<a name="l01338"></a>01338     }
<a name="l01339"></a>01339   
<a name="l01340"></a>01340   
<a name="l01341"></a>01341   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01342"></a>01342     {
<a name="l01343"></a>01343     x.<a class="code" href="a00492.html#gc9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l01344"></a>01344     }
<a name="l01345"></a>01345   
<a name="l01346"></a>01346   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gc81cbe704e50a7b256750a391ac7bae8"></a><!-- doxytag: member="diskio::save_field_std_string" ref="gc81cbe704e50a7b256750a391ac7bae8" args="(const field&lt; std::string &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_field_std_string           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00037.html">field</a>&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00597.html#l01352">1352</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00593.html#l00160">arma_warn()</a>, <a class="el" href="a00599.html#l00251">field&lt; oT &gt;::at()</a>, <a class="el" href="a00653.html#l00732">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00597.html#l00213">gen_tmp_name()</a>, <a class="el" href="a00600.html#l00032">field&lt; oT &gt;::n_cols</a>, <a class="el" href="a00600.html#l00031">field&lt; oT &gt;::n_rows</a>, <a class="el" href="a00653.html#l00702">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00597.html#l00277">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00599.html#l00908">field_aux::save()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01353"></a>01353   {
<a name="l01354"></a>01354   arma_extra_debug_sigprint();
<a name="l01355"></a>01355   
<a name="l01356"></a>01356   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00491.html#g81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01357"></a>01357   std::ofstream f( tmp_name.c_str(), std::fstream::binary );
<a name="l01358"></a>01358   
<a name="l01359"></a>01359   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01360"></a>01360     {
<a name="l01361"></a>01361     <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"couldn't write "</span>, tmp_name);
<a name="l01362"></a>01362     }
<a name="l01363"></a>01363   <span class="keywordflow">else</span>
<a name="l01364"></a>01364     {
<a name="l01365"></a>01365     <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row&lt;x.<a class="code" href="a00037.html#98d956dc3c4571ff9d29ee3d709d0202" title="number of rows in the field (read-only)">n_rows</a>; ++row)
<a name="l01366"></a>01366     <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col&lt;x.<a class="code" href="a00037.html#d33a934565f6e02edb4e7f6d1331d34a" title="number of columns in the field (read-only)">n_cols</a>; ++col)
<a name="l01367"></a>01367       {
<a name="l01368"></a>01368       f &lt;&lt; x.<a class="code" href="a00492.html#g0e24e346da9e98e461bf32ad674216cf" title="element accessor; no bounds check">at</a>(row,col);
<a name="l01369"></a>01369       
<a name="l01370"></a>01370       <span class="keywordflow">if</span>(col &lt; x.<a class="code" href="a00037.html#d33a934565f6e02edb4e7f6d1331d34a" title="number of columns in the field (read-only)">n_cols</a>-1)
<a name="l01371"></a>01371         {
<a name="l01372"></a>01372         f &lt;&lt; <span class="charliteral">' '</span>;
<a name="l01373"></a>01373         }
<a name="l01374"></a>01374       <span class="keywordflow">else</span>
<a name="l01375"></a>01375         {
<a name="l01376"></a>01376         f &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l01377"></a>01377         }
<a name="l01378"></a>01378       }
<a name="l01379"></a>01379     
<a name="l01380"></a>01380     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01381"></a>01381     
<a name="l01382"></a>01382     <a class="code" href="a00488.html#gd87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">"trouble writing "</span>, tmp_name );
<a name="l01383"></a>01383     
<a name="l01384"></a>01384     f.flush();
<a name="l01385"></a>01385     f.close();
<a name="l01386"></a>01386     
<a name="l01387"></a>01387     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01388"></a>01388       {
<a name="l01389"></a>01389       <a class="code" href="a00491.html#g21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01390"></a>01390       }
<a name="l01391"></a>01391     
<a name="l01392"></a>01392     }
<a name="l01393"></a>01393   
<a name="l01394"></a>01394   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g7b3972f2cb001aa18b83d26305b6ed00"></a><!-- doxytag: member="diskio::load_field_std_string" ref="g7b3972f2cb001aa18b83d26305b6ed00" args="(field&lt; std::string &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_field_std_string           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00037.html">field</a>&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00597.html#l01400">1400</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00599.html#l00251">field&lt; oT &gt;::at()</a>, <a class="el" href="a00653.html#l00732">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00600.html#l00032">field&lt; oT &gt;::n_cols</a>, <a class="el" href="a00600.html#l00031">field&lt; oT &gt;::n_rows</a>, <a class="el" href="a00599.html#l00478">field&lt; oT &gt;::reset()</a>, <a class="el" href="a00653.html#l00702">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00599.html#l00156">field&lt; oT &gt;::set_size()</a>.</p>

<p>Referenced by <a class="el" href="a00599.html#l00919">field_aux::load()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01401"></a>01401   {
<a name="l01402"></a>01402   arma_extra_debug_sigprint();
<a name="l01403"></a>01403   
<a name="l01404"></a>01404   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01405"></a>01405   
<a name="l01406"></a>01406   std::ifstream f( name.c_str() );
<a name="l01407"></a>01407   
<a name="l01408"></a>01408   <span class="keywordflow">if</span>(f.fail())
<a name="l01409"></a>01409     {
<a name="l01410"></a>01410     load_okay = <span class="keyword">false</span>;
<a name="l01411"></a>01411     arma_extra_debug_print(<span class="stringliteral">"unable to read "</span>, name);
<a name="l01412"></a>01412     }
<a name="l01413"></a>01413   <span class="keywordflow">else</span>
<a name="l01414"></a>01414     {
<a name="l01415"></a>01415     <span class="comment">//</span>
<a name="l01416"></a>01416     <span class="comment">// work out the size</span>
<a name="l01417"></a>01417     
<a name="l01418"></a>01418     <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l01419"></a>01419     <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l01420"></a>01420     
<a name="l01421"></a>01421     <span class="keywordtype">bool</span> f_n_cols_found = <span class="keyword">false</span>;
<a name="l01422"></a>01422     
<a name="l01423"></a>01423     std::string line_string;
<a name="l01424"></a>01424     std::string token;
<a name="l01425"></a>01425     
<a name="l01426"></a>01426     <span class="keywordflow">while</span>( (f.good() == <span class="keyword">true</span>) &amp;&amp; (load_okay == <span class="keyword">true</span>) )
<a name="l01427"></a>01427       {
<a name="l01428"></a>01428       std::getline(f, line_string);
<a name="l01429"></a>01429       <span class="keywordflow">if</span>(line_string.size() == 0)
<a name="l01430"></a>01430         <span class="keywordflow">break</span>;
<a name="l01431"></a>01431       
<a name="l01432"></a>01432       std::stringstream line_stream(line_string);
<a name="l01433"></a>01433       
<a name="l01434"></a>01434       <a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> line_n_cols = 0;
<a name="l01435"></a>01435       <span class="keywordflow">while</span> (line_stream &gt;&gt; token)
<a name="l01436"></a>01436         line_n_cols++;
<a name="l01437"></a>01437       
<a name="l01438"></a>01438       <span class="keywordflow">if</span>(f_n_cols_found == <span class="keyword">false</span>)
<a name="l01439"></a>01439         {
<a name="l01440"></a>01440         f_n_cols = line_n_cols;
<a name="l01441"></a>01441         f_n_cols_found = <span class="keyword">true</span>;
<a name="l01442"></a>01442         }
<a name="l01443"></a>01443       <span class="keywordflow">else</span>
<a name="l01444"></a>01444         {
<a name="l01445"></a>01445         <span class="keywordflow">if</span>(line_n_cols != f_n_cols)
<a name="l01446"></a>01446           {
<a name="l01447"></a>01447           load_okay = <span class="keyword">false</span>;
<a name="l01448"></a>01448           <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"inconsistent number of columns in "</span>, name );
<a name="l01449"></a>01449           }
<a name="l01450"></a>01450         }
<a name="l01451"></a>01451       
<a name="l01452"></a>01452       ++f_n_rows;
<a name="l01453"></a>01453       }
<a name="l01454"></a>01454       
<a name="l01455"></a>01455     <span class="keywordflow">if</span>(load_okay == <span class="keyword">true</span>)
<a name="l01456"></a>01456       {
<a name="l01457"></a>01457       f.clear();
<a name="l01458"></a>01458       f.seekg(0, ios::beg);
<a name="l01459"></a>01459       <span class="comment">//f.seekg(start);</span>
<a name="l01460"></a>01460       
<a name="l01461"></a>01461       x.<a class="code" href="a00492.html#gfd7a090f4134eab2ab1c805fb867e85c" title="change the field to have the specified number of elements, assuming a column-major...">set_size</a>(f_n_rows, f_n_cols);
<a name="l01462"></a>01462     
<a name="l01463"></a>01463       <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00037.html#98d956dc3c4571ff9d29ee3d709d0202" title="number of rows in the field (read-only)">n_rows</a>; ++row)
<a name="l01464"></a>01464         {
<a name="l01465"></a>01465         <span class="keywordflow">for</span>(<a class="code" href="a00576.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00037.html#d33a934565f6e02edb4e7f6d1331d34a" title="number of columns in the field (read-only)">n_cols</a>; ++col)
<a name="l01466"></a>01466           {
<a name="l01467"></a>01467           f &gt;&gt; x.<a class="code" href="a00492.html#g0e24e346da9e98e461bf32ad674216cf" title="element accessor; no bounds check">at</a>(row,col);
<a name="l01468"></a>01468           }
<a name="l01469"></a>01469         }
<a name="l01470"></a>01470       }
<a name="l01471"></a>01471     
<a name="l01472"></a>01472     <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l01473"></a>01473       {
<a name="l01474"></a>01474       load_okay = <span class="keyword">false</span>; 
<a name="l01475"></a>01475       <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"trouble reading "</span>, name );
<a name="l01476"></a>01476       }
<a name="l01477"></a>01477     
<a name="l01478"></a>01478     f.close();
<a name="l01479"></a>01479     }
<a name="l01480"></a>01480   
<a name="l01481"></a>01481   
<a name="l01482"></a>01482   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01483"></a>01483     {
<a name="l01484"></a>01484     x.<a class="code" href="a00492.html#gc9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l01485"></a>01485     }
<a name="l01486"></a>01486   
<a name="l01487"></a>01487   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gc7ef1ae013236ff30e38af063dd99120"></a><!-- doxytag: member="diskio::load_field_auto_detect" ref="gc7ef1ae013236ff30e38af063dd99120" args="(field&lt; T1 &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_field_auto_detect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00037.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Try to load a <a class="el" href="a00037.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> by automatically determining its type. 
<p>

<p>Definition at line <a class="el" href="a00597.html#l01495">1495</a> of file <a class="el" href="a00597.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00593.html#l00026">arma_print()</a>, <a class="el" href="a00597.html#l01081">load_field_arma_binary()</a>, <a class="el" href="a00597.html#l01224">load_field_ppm_binary()</a>, and <a class="el" href="a00599.html#l00478">field&lt; oT &gt;::reset()</a>.</p>

<p>Referenced by <a class="el" href="a00599.html#l00777">field_aux::load()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01496"></a>01496   {
<a name="l01497"></a>01497   arma_extra_debug_sigprint();
<a name="l01498"></a>01498   
<a name="l01499"></a>01499   <a class="code" href="a00015.html">arma_type_check&lt;is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l01500"></a>01500   
<a name="l01501"></a>01501   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_FLD_BIN = <span class="stringliteral">"ARMA_FLD_BIN"</span>;
<a name="l01502"></a>01502   <span class="keyword">static</span> <span class="keyword">const</span> std::string           P6 = <span class="stringliteral">"P6"</span>;
<a name="l01503"></a>01503   
<a name="l01504"></a>01504   std::fstream f;
<a name="l01505"></a>01505   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l01506"></a>01506   
<a name="l01507"></a>01507   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01508"></a>01508     {
<a name="l01509"></a>01509     x.<a class="code" href="a00492.html#gc9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l01510"></a>01510     arma_extra_debug_print(<span class="stringliteral">"unable to read "</span>, name);
<a name="l01511"></a>01511     }
<a name="l01512"></a>01512   <span class="keywordflow">else</span>
<a name="l01513"></a>01513     {
<a name="l01514"></a>01514     <a class="code" href="a00198.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;char&gt;</a> raw_header(ARMA_FLD_BIN.length() + 1);
<a name="l01515"></a>01515     
<a name="l01516"></a>01516     f.read(raw_header.memptr(), ARMA_FLD_BIN.length());
<a name="l01517"></a>01517     raw_header[ARMA_FLD_BIN.length()] = <span class="charliteral">'\0'</span>;
<a name="l01518"></a>01518     
<a name="l01519"></a>01519     <span class="keyword">const</span> std::string header = raw_header.mem;
<a name="l01520"></a>01520     
<a name="l01521"></a>01521     <span class="keywordflow">if</span>(ARMA_FLD_BIN == header.substr(0,ARMA_FLD_BIN.length()))
<a name="l01522"></a>01522       {
<a name="l01523"></a>01523       <a class="code" href="a00491.html#gf6b48a29fa9de8cd55ca8f69a49ba884">load_field_arma_binary</a>(x, name);
<a name="l01524"></a>01524       }
<a name="l01525"></a>01525     <span class="keywordflow">else</span>
<a name="l01526"></a>01526     <span class="keywordflow">if</span>(P6 == header.substr(0,P6.length()))
<a name="l01527"></a>01527       {
<a name="l01528"></a>01528       <a class="code" href="a00491.html#gb548665b4c0b3f035b4f20775500cb7d">load_field_ppm_binary</a>(x, name);
<a name="l01529"></a>01529       }
<a name="l01530"></a>01530     <span class="keywordflow">else</span>
<a name="l01531"></a>01531       {
<a name="l01532"></a>01532       <a class="code" href="a00488.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unsupported header in "</span>, name);
<a name="l01533"></a>01533       x.<a class="code" href="a00492.html#gc9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l01534"></a>01534       }
<a name="l01535"></a>01535     
<a name="l01536"></a>01536     f.close();
<a name="l01537"></a>01537     }
<a name="l01538"></a>01538   
<a name="l01539"></a>01539   }
</pre></div>
<p>

</div>
</div><p>
</div>
</BODY>
</HTML>
